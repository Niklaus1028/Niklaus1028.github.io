{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Niklaus Yu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-01-28T03:13:25.000Z","updated":"2020-01-28T03:17:26.016Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-28T03:07:35.000Z","updated":"2020-01-28T03:10:00.598Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Gateway","slug":"Gateway","date":"2020-04-08T06:23:09.000Z","updated":"2020-04-10T11:53:58.924Z","comments":true,"path":"2020/04/08/Gateway/","link":"","permalink":"http://yoursite.com/2020/04/08/Gateway/","excerpt":"","text":"简介 由于有如此众多的客户端和服务器，在云体系结构中包括一个API网关通常会很有帮助。网关可以负责保护和路由消息，隐藏服务，限制负载以及许多其他有用的事情。Spring Cloud Gateway为您提供对API层的精确控制，集成了Spring Cloud服务发现和客户端负载平衡解决方案，以简化配置和维护。 SpringCloud Gateway 是Spring cloud的一个全新的项目，基于Spring Framework 5，Project Reactor和Spring Boot 2.0等技术开发的网关，它旨在为为微服务架构提供简单有效的统一的API路由管理方式。 SpringCloud Gateway作为Spring cloud 生态系统中的网关，目标是替代zuul，在Springcloud2.0以上的版本中，没有对新版本的zuul2.0一盒收纳柜最新高性能版本进行集成，仍然还是使用的是Zuul1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway 是基于WebFlux框架实现的，而WebFlux框架使用了高性能的Reactor模式通信框架Netty。 Spring Cloud Gateway的目标提供统一的路由方式且基于Filter链的方式提供网关的基本功能，例如：安全，监控/指标，和限流。 Spring Cloud架构亮点 特征Spring Cloud Gateway功能： 基于Spring Framework 5，Project Reactor和Spring Boot 2.0构建 能够匹配任何请求属性上的路由。 谓词和过滤器特定于路由。 Hystrix断路器集成。 Spring Cloud DiscoveryClient集成 易于编写的谓词和过滤器 请求速率限制 路径改写 三大核心概念Route（ 路由）路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由。Predicate（断言）开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由。Filter（过滤）值得是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。工作流程 Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run. 客户端向Spring Cloud Gateway发出请求。然后在Gate Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway Web Handler。 Handler再通过指定的过滤器来讲请求发送到实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理之前（“pre”）或之后（”post“）执行业务逻辑。 Filter在”pre“类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等 在”post“类型的过滤器中可以做响应内容、响应头修改，日志输出，流量监控等有着非常重要的作用。 核心逻辑：路由转发+执行过滤器链","categories":[{"name":"Springcloud","slug":"Springcloud","permalink":"http://yoursite.com/categories/Springcloud/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Hadoop","slug":"Hadoop","date":"2020-04-08T06:23:09.000Z","updated":"2020-04-10T09:27:47.047Z","comments":true,"path":"2020/04/08/Hadoop/","link":"","permalink":"http://yoursite.com/2020/04/08/Hadoop/","excerpt":"","text":"大数据简介一、大数据特征 - 6V 数据体量大，一般从TB级别开始计算 数据种类和来源多 数据的增长速度越来越快 数据的价值密度越来越低，但是这不意味着想要的数据越来越少，相反，想要的数据越来越多的，但是样本总量的增长速度是要高于想要的数据的增长速度的 数据的真实性/质量 数据的连通性 数据的动态性、数据的可视化、合法性 二、概述 Hadoop是Apache提供的一个开源的、可靠的、可扩展的系统架构，可以利用分布式架构来进行海量数据的存储以及计算 Hadoop之父：Doug Cutting（道格·卡丁） 需要注意的是Hadoop处理的是离线数据，即在数据已知以及不要求实时性的场景下使用 Hadoop发行版: a. Apache版本最基本的版本，入门学习较好。原生版本管理相对比较混乱 b. CDH版本是Cloudera提供的商业版本，相对Apache Hadoop更加的稳定和安全 c. Hortonworks文档相对完善友好 三、 版本： Hadoop1.0：包含Common，HDFS，和MapReduce ，停止更新 Hadoop2.0：包含Common，HDFS，和MapReduce，YARN。1.0和2.0完全不兼容，Hadoop2.8之前的不包含ozone Hadoop3.0：包含Common，HDFS，和MapReduce，YARN和ozone。 四、模块 Hadoop Common: 基本模块 Hadoop Distributed File System (HDFS™): 分布式存储 Hadoop YARN:进行任务调度和资源管理 Hadoop MapReduce: 分布式计算 Hadoop Ozone:对象存储 五、安装方式 单机模式：只能启动MapReduce 伪分布式：只能启动HDFS，MapReduce和YARN的大部分功能 完全分布式：能启动Hadoop的所有功能 HDFS一、概述 HDFS是Hadoop提供一套用于进行分布式存储的文件系统 HDFS根据Google的GFS来进行实现的 二、基本概念 HDFS主要包含2类进程：NameNode和DataNode 在HDFS中，上传的文件自动的进行切块，每一个数据块称之为一个Block HDFS会自动对数据进行备份，每一个备份称之为副本（replication/replicas）默认为3 HDFS仿照Linux设置一套虚拟的文件系统,根路径/ 三、Block Block是HDFS中存储数据的基本单位，即在HDFS中所有数据都是以Block形式存储 Block默认是128M大小，可以通过dfs.blocksize(在hdfs-site.xml，单位是字节)来设置 如果一个文件不到一个Block的大小，那么注意，这个文件本身多大block就是多大 在HDFS中，会给每一个Block自动分配一个全局递增的Block ID 在HDFS中，会给每一个Block分配一个时间戳（Generation Stamp）编号 切块的意义 为了能够存储超大文件 为了能够进行快速备份 四、NameNode NameNode是HDFS中的主节点（Master），作用：管理DataNode和记录与元数据（metadata） 元数据是描述数据的数据 —在HDFS中，元数据对存储的文件进行描述，主要包含 文件的存储路径，例如/txt/a.txt 文件的权限 上传的用户和用户组 文件的大小 Block的大小 文件和BlockID的映射关系 副本数量 BlockID和DataNode的映射关系 元数据是存储在内存以及磁盘中 维系在内存中的目的是为了快速查询 维系在磁盘中的目的是为了崩溃恢复 元数据在磁盘中的存储路径由hadoop.tmp.dir(core-site.xml)属性来决定的 元数据的记录和fsimage以及edits文件相关 edits记录写操作 fsimage：记录元数据。fsimage中的元数据往往是落后于内存中的元数据 当NameNode接受到写请求的时候，NameNode会先将这个写请求记录到edits-iprogress中，如果记录成功则修改内存中的元数据。内存中的元数据修改成功之后会给客户端返回一个成功信号。这个过程中fsimage文件中的元数据没有被修改 当达到指定条件的时候，触发edits_inprogress文件的滚动，edits_inprogress会滚动生成edits文件，会产生一个新的edits_inprogress。在edits_inprogress滚动过程中，会触发fsimage文件的更新，会根据edits_inprogress中的命令去修改fsimage文件中的元数据 edits_inprogress文件的滚动条件 空间：当edits_inprogress文件达到指定大小（64m通过f s.checkpoint.size，单位是字节 - core-site.xml)的时候，会产生滚动 时间：当距离上一次滚动的时间间隔（默认3600s，通过f s.checkpoint.period来调节，默认单位是秒-core site.xml）达到指定大小，会产生滚动 重启：当NameNode重启的时候，自动触发edits——inprogress文件的滚动 强制滚动：可以利用 hadoop dfsadmin -rollEdits来强制滚动 NameNode通过心跳机制来管理DataNode， DataNode定时的通过RPC的方式来给NameNode发送心跳。 默认情况下是每隔3s给NameNode发送心跳，可以通过dfs.heartbeat.interval来修改，单位是秒 —hdfs site.xml NameNode超过10min没有收到DataNode的心跳，就会认为这个DataNode已经Lost（丢失），那么此时NameNode就会讲这个DataNode上的Block备份到其他节点，保证整个集群的副本数量 心跳信息 当前DataNode的状态（预服役、服役、预退役） 当前DataNode存储的Block信息 clusterid：集群编号。当NameNode被格式化的时候，会自动计算产生一个clusterid，每格式化一次就会重新计算产生，当HDFS集群启动的时候，NameNode会将clusterid分发给每一个DataNode的信息之后，会先校验clusterid是否一致；同样，DataNode收到NameNode的指令的时候也会校验clusterid。DataNode只能接受一次clusterid 当NameNode重启的时候，会自动触发edits_inprogress文件的滚动，产生一个新的edits文件和一个新的edits_inprogress文件，同时更新fsimage。当更新完fsimage之后，NameNode就会将fsimage文件中的内容加载到内存中，加载完成后，NameNode等待DataNode的心跳。如果在指定时间内没有收到心跳，则认为节点丢失重新备份。如果收到DataNode的心跳，那么NameNode会校验这个心跳信息，这个过程称之为安全模式。在安全模式中，NameNode如果校验失败，则试图恢复数据，恢复完成之后会重新校验；如果校验成功，则自动退出安全模式。 当NameNode重启的时候，自动进入安全模式，实际开发过程中，如果进入安全模式，需要等待NameNode自动退出安全模式，但是在合理的时间内，NameNode没有退出安全模式，就说明数据产生了不可挽回的丢失，此时需要强制退出安全模式（hadoop afsadmin -safemode leave） 在安全模式中，HDFS不对外提供写服务 正因为有安全模式的存在所以在为分布式中副本数量设置为1； 五、多副本的放置策略 第一个副本 如果集群内部上传，那么谁上传第一个副本就放在谁身上 如果是集群外部上传，NameNode会选择相对较闲的DataNode的节点存储数据 第二个副本 Hadoop2.7之前：第二个副本是放在和第一个副本不同机架的节点上 Hadoop2.7开始：第二个副本是放在和第一个副本相同机架的节点上 第三个副本 Hadoop2.7之前：第三个副本是放在和第二个副本相同机架的节点上 Hadoop2.7开始：第三个副本是放在和第二个副本不同机架的节点上 更多副本：那个几点相对空闲就放在谁身上 六、 机架感知策略 在HDFS中默认没有启用，需要在hadoop-site.xml中配置topology.script.file.name开启机架感知策略 HDFS的机架感知策略是通过指定的脚本来进行配置，这个脚本可以是python和shell，所谓的机架就是一个映射，只需要将DataNode的主机名或者ip映射到值上就对应了机架 机架指的是逻辑机架不是物理机架，允许将一个或几个物理机架上的节点映射到同一个逻辑机架上，但是实际开发中，一般是一个物理机架对应一个逻辑机架 七、DataNode DataNode是HDFS中的从节点，作用：存储数据，数据以block的形式来存储 DataNode会将数据存储在磁盘中，在磁盘上的存储位置由hadoop.tmp.dir属性来决定 DataNode的状态:预服役，服役，预退役，退役 DataNode会主动给NameNode发送心跳来进行注册 八、SecondaryNameNode SecondaryNameNode并不是NameNode备份，而是辅助NameNode进行edits_inprogress文件的滚动和fsimage的更新 在HDFS集群中，如果存在SecondaryNameNode，edits_inprogress文件的滚动和fsimage的更新由SecondaryNameNode来做，如果不存在，上述事情由NameNode自己来做，存活与否不影响集群向外提供服务，只会影响效率 在HDFS集群中，支持的结构一般是有两种 1个NameNode+1个SecondaryNameNode+多个DataNode 2个NameNode+多个DataNode 因为在HDFS中，NameNode是核心节点，所以一般要考虑NameNode的备份，那么此时就需要系用双NameNode机制，一个处于active状态，另一个处于备份状态，当active的NameNode宕机后，备份的立即切换为active，在实际工作中以第二方案为主，这样实现了集群的高可用（HA）。 九、回收站机制 在HDFS中，回收站机制默认不开启，即删除命令会立即生效， 如果要开启回收站机制，要在core-site.xml中配置 十、dfs目录 dfs目录实际上就是HDFS的数据目录，由hadoop.tmp.dir属性来决定存储路径 dfs子目录 a. data 对应datanode数据的存储路径 b. name 对应namenode数据的存储路径 c. namesecondary 对应namesecondary数据的存储路径 实际开发中，三个子目录应该出现在三个不同的节点上 in_use.lock用于标记是否已经启动对应的进程 每一个blk文件对应一个.meta,这个.meta文件可以认为是对blk的校验 HDFS在第一次启动的时候，间隔1min之后出发edits_inprogress文件的滚动，之后就按照指定的条件进行滚动 在HFDS中，每一次写操作看成一次事务，分配一个全局递增的事物的id，简称zxid","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"ZooKeeper","slug":"ZooKeeper","date":"2020-04-07T01:45:00.000Z","updated":"2020-04-08T03:57:28.624Z","comments":true,"path":"2020/04/07/ZooKeeper/","link":"","permalink":"http://yoursite.com/2020/04/07/ZooKeeper/","excerpt":"","text":"简介一、概述 ZooKeeper是由Yahoo（雅虎）开发的，后来提供给Apache管理的一套开源的，用于进行分布式的框架 Zookeeper是根据Google的关于Chubby Lock来设计实现的 Zookeeper是是一个中心化分布式框架的管理框架 zookeeper.out：启动日志，可以查看启动失败原因 二、安装 单机模式：在一台机器上安装，往往只能启动这个框架的一部分的功能 伪分布式：在集群中安装，能够启动这个框架的所有功能 完全分布式：在集群中安装，能启动这个框架的所有功能 基本概念一、基本理论 Zookeeper本身是一个树状结构 - znode树 根结点时/ 每一个节点称之为Znode节点 每一个持久节点都可以挂载字节点，每一个临时节点都没有字节点 每一个节点都需要携带数据，这个数据往往是对节点的描述 不存在相对路径的说法,所有节点都需要从/计算 zookeeper将数据维系在磁盘以及内存中 维系在内存中的目的是为了快速读写 维系在磁盘中的目的是为了防止奔溃 zookeeper在磁盘中存储的位置在dataDir指定 理论上来说，是可以做缓存服务器来使用的 ，但实际开发中不会这么做。因为zookeeper的主要作用作为协调框架来使用的，如果作为缓存服务器使用会占用大量内存,降低zookeeper的协调效率 在节点下不能存在同名节点 在zookeeper中，会讲每一次的写操作看作是一个事务，然后给这个事务分配一个全局递增的编号，称之为事务id，简称Zxid 二、命令 ls / 查看根目录的字节点 create /video ‘manage video servers’ 创建节点 delete / 删除节点下无字节点 rmr /video 递归删除 set /news ‘manage news servers’ 修改节点信息 get /news 获取节点信息 create -e /video ‘’ 创建临时节点 三、节点信息 cZxid 创建事务id ctime 创建时间 mZxid 修改事务id mtime 修改时间 pZxid 字节点个数变化的事务id cversion 字节点个数变化的次数 dataVersion 数据变化的次数 aclVersion 权限变化次数 ephemeralOwner dataLength numChildren 字节点的数目 123456789101112manage news serverscZxid &#x3D; 0x9ctime &#x3D; Fri Apr 03 10:44:15 CST 2020mZxid &#x3D; 0xamtime &#x3D; Fri Apr 03 10:44:42 CST 2020pZxid &#x3D; 0xdcversion &#x3D; 3dataVersion &#x3D; 1aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 19numChildren &#x3D; 3 四、节点类型 顺序节点 create -s /news/n ‘ ‘ s指的是sequence 非顺序节点 create /news/n ‘’ 概述 在配置zookeeper的时候，并没有指定那台服务器节点成为leader，那台服务器是follower，但是zookeeper集群启动之后自动出现了leader和follower，那么说明zookeeper在启动过程中出现了选举过程。 在zookeeper集群刚刚启动的时候，这个时候每一个节点都会推荐自己成为leader，并且将自己的选举信息发送给其他节点。 节点之间会两两比较选举信息，比较成功的会进行下一轮选举，经过多轮选举，最终胜出的节点成为leader。 细节 选举信息： a. 每一台服务器（节点）的最大事务id b. 选举编号 -myid c. 逻辑时钟值 -控制节点的选举轮数 比较原则： a.先比较两个节点的事务id，谁大谁赢 - 事务id越大，说明接受的写操作越频繁 b. 如果节点的事务id越大一样，则比较myid，谁大谁赢 - 在zoo.cfg,要求server.x中的x不一致 c. 一个节点要想成为leader，至少要胜过一半的节点 - 过半性 d. 在zookeeper集群中为了保证稳定性，一旦确定leader，新加入的节点自动成为follower e. 为了避免出现单点故障问题，一旦老leader出现问题，zookeeper集群会自动触发选举机制，会自动选觉一个新的节点成为leader。 f. 因为集群中出现多个leader，这个现象称之为脑裂 g.脑裂产生条件 网络产生了分裂/隔离 分裂之后进行了选举h. 在zookeeper中，当存活的解ID哪个数不足一半的时候，那么存活的节点之间不选觉也不对外提供服务 - 过半性i. 在zookeeper集群中一般把节点个数设置为奇数以满足过半性j.在zookeeper集群中选举出leader会分配一个全局递增的编号，也会通知其他节点，称之为epochid。在zookeeper集群中如果出现多个leader，会保留epochid最大的id为leader，同时将其他的leader节点的状态进行切换，切换成followerk. 集群中节点的状态 voting/looking 选举状态 follower 追随者/跟随者 leader 领导者 observer 观察者l.选觉状态下不对外提供服务 ZAB一、概述 ZAB（Zookeeper Atomic Broadcast）是一套专门为zookeeper设计的用于进行原子广播和崩溃恢复的协议。 ZAB基于2pc算法来进行设计，利用了过半性和PAXOS算法来进行了改善 - 核心思想：一票否决二、原子广播 作用：保证数据的一致性 - 在zookeeper中访问任意一个节点获取到的数据都是相同的 原子广播是基于2pc算法来设计的，然后引入过半性来进行改进 2pc - two phase commit -二阶段提交 -实际过程中要么请求-提交，要么请求-中止 请求阶段：协调者收到任务之后，会将任务发给每一个参与者，等待参与者的反馈 调教阶段：如果协调者收到所有参与者的yes，那么协调者要求所有的参与者执行刚才的任务 中止阶段：如果协调者如果没有接受到所有参与者接受请求的信息，就会拒绝这次任务 原子广播的流程： 记录日志失败的可能性 日志文件被占用 - 此时记录的时候却是以只读模式 - 在计算机中，一个文件一旦被某个进程打开其他进程往往以只读模式来打开 磁盘管道损坏 磁盘存储已满 当follower记录日志失败，但是leader却还要求follower执行这个任务的时候，follower就会向leader发送请求，重新获取任务然后leader会将任务放入到队列中发送给follower，重新记录日志；如果再次记录失败，会将重新给leader发送请求重新记录直到成功为止。 - 如果是第一种可能性导致日志记录失败，只要日志未见被释放那么日志就有可能重新记录成功；但是如果是后两种可能，那么就属于硬件环境问题 三、崩溃恢复 作用：避免单点故障，保证集群的高可用 在zookeeper集群中，当leader节点丢失或宕机时，集群不会因为一个节点而不服务，而是会通过选举机制重新选取leader节点，这个过程叫崩溃恢复。 每一个新上任的leader会把自己的epochid分发给每一个follower，follower在收到epochid会把它存储到acceptepochid中。 当一个节点重启炼乳集群之后，这个节点会先寻找当前节点的最大事务id，将自己的最大事务id发送给leader进行比较，如果发现不一致，leader就会将所缺的操作重新放到队列中发送给follower重新补奇，补齐过程中这个follower暂时不会对外提供服务 在集群中，事务id实际上有64位二进制数字（16个十六进制数字）组成，其中高32位代表epochid，低32位代表的是事务id version-2 中log中记录写操作，snap记录整个zookeeper的树结构 四、观察者 观察者的特点：既不参与投票也不参与选举，但是会监听 投票或者选举结果，根据结果来执行对应的操作 在实际开发中，如果集群庞大，为了提高效率，往往将90%的节点设置成observer。如果在异构网络中，也会将绝大部分的节点设置为观察者 在zookeeper中observer不参与选举但是选举出leader之后，观察者听从leader命令；如果leader和follow二决定执行或者不指定某个操作的时候，observer也需要跟着执行或不执行。 observer没有投票权和选举权，所以observer是否存活并不影响过半。 五、 特性 过半性：过半选举，过半存活，过半执行 原子性：要么所有的节点都执行请求，要么都不执行 数据一致性：访问任意节点所拿到的数据是一致的 顺序性：leader会讲请求发送到队列中发送给follower，所以保证leader和follower的请求的执行顺序是相同的 实时性：实时监控zookeeper的集群变化 可靠性：奔溃恢复 - 不会因为一个节点当即就导致整个集群不服务 AVRO一、概述 AVRO是由Apache提供的一套用于序列化和RPC的机制 AVRO原本是Hadoop的子组件，后来AVRO被独立出来成为了一个顶级项目 二、序列化 序列化实际上是指按照指定的格式将数据转化为其他形式 序列化的作用：为了方便数据的存储和传输 序列化的衡量标准： 序列化花费的时间，占用的资源等 序列化之后产生的数据量的大小 考虑序列化机制本身是否跨平台跨语言 如果数据要在不同的语言之间传输，那么意味着数据要做到数据与语言无关 数字，布尔值，字符/字符串 字符/字符串与编码有关-只要两种计算机语言用同一套码表就可以进行数据的传输 实际开发过程中，绝大部分的序列化机制都考虑转化为字符串-AVRO实际就是将对象转化为jason 三、RPC RPC(Remote Procedure Call,远程过程调用)允许程序员在一个节点（服务器）上去远程调用另一个节点上的方法而不用显示的实现这个方法 特点：简单，高效，通用 RPC的stub（存根）就是限制不同的节点上的方法签名是一致的，在Java中一般用接口","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"JUC","slug":"JUC","date":"2020-03-31T07:54:44.071Z","updated":"2020-04-02T15:36:45.595Z","comments":true,"path":"2020/03/31/JUC/","link":"","permalink":"http://yoursite.com/2020/03/31/JUC/","excerpt":"","text":"原子性操作–Atomic 原子性 原子性操作实际上就是针对属性来提供线程安全的方法，在底层会自动采用CAS来保证线程安全。 volatile是Java提供的轻量级的线程同步机制 阻塞队列 BlockingQueue原则： 遵循FIFO 往往是有界的，容量固定不变 具有阻塞特性：如果队列已满，则试图放入的线程会被阻塞；如果队列为空，就会阻塞尝试获取的线程 不允许元素null 方法： 抛出异常 返回特殊值 产生阻塞 定时阻塞 添加 add - IllegalStateException offer - false put offer 获取 remove - NoSuchElementException poll - null take poll ConcurrentMap -并发映射 ConcurrentHashMap底层基于数组h+链表来存储数据，数组的每一个位置称之为桶 默认初始容量16（桶的数量），加载因子0.75 如果指定容量,底层会进行计算，实际容量一定是2的n次方 每次扩容每次增加一倍的桶数,扩容之后需要rehash操作123456789101112131415161718public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; &#125;//底层算法private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 分段锁，封桶锁机制，不是把整个映射锁起来 在jdk1.7引入读写锁ConcurrentNavigableMap - 并发导航映射 ConcurrentNavigableMap提供了用于截取子映射的方法 ConcurrentNavigableMap本身是一个接口，所以更多的是使用它的实现类ConcurrentSkipListMap - 并发跳跃表映射 跳跃表 针对有序集合 适合于增删少，查询多的场景 跳跃表可以进行多层提取，最上层的跳跃表的元素个数不能少于2个 跳跃表是典型的“以空间换时间“的产物 在跳跃表中新添元素提取到上层跳跃表，遵循抛硬币原则 跳跃表的时间复杂度是O(logn)ExecutorService概述 本质上是一个线程池线程池：减少服务器的线程的创建和销毁，做到连接的复用 刚开始创建时空的，里面不包含任何线程 每接受一个请求，线程池都会创建一个线程(核心线程）来处理这个请求，在创建线程的时候就需要指定线程的数量 在核心线程达到指定数量之前，来一个请求就会创建一个新的线程来处理这个请求，直到线程满了就不再创建 核心线程处理完这个请求不会销毁，等待下一个请求 如果核心线程全部沾满，新来的请求会暂存在工作队列，工作队列本身是一个阻塞式队列 当核心线程有空的时候，就会从工作队列中取出交给核心线程处理 如果工作队列被全部占用，有接受到新的请求，会将这个请求叫个临时线程来处理 当临时线程处理完请求之后不会立即结束，而是会存活一段时间，如果在这个时间段内接受到新的请求，会处理新的请求，如果没有接收到请求，就会被kill掉 临时线程不会从工作队列中拿出请求处理 当临时线程全部占用，那么新来的请求就会交给执行助手来拒绝处理，在实际开发中，如果需要拒绝请求，可能会产生多部操作，例如记录日志，页面跳转，请求重发 ScheduledExecutorService：定时调度执行器服务。在线程池的基础上加入了定时调度效果。这个线程池本身是很多定时调度机制的底层实现 内存模型栈内存：执行方法- 计算 栈内存是线程独享的 堆内存：存储对象，线程共享 方法区：存储类信息（字节码，静态，常量）。线程共享的 本地方法栈：执行本地方法，线程独享 本地方法是指在Java中用native声明但使用其他语言实现的方法 pc计数器/寄存器：指令计数，线程独享如果需要计算一台服务器的线程承载量，考虑线程独享部分。在jdk1.8中，栈内存最小128kpc计数器一般只占几个字节，可以忽略 红黑树定义a. 红黑树本质上一棵自平衡二叉查找树 b.特征： i. 所有节点的颜色非红即黑 ii. 根节点为黑色 iii. 红节点的子节点一定黑节点，黑节点的子节点可以是红节点也可以是黑节点 iv. 最底层的叶子节点一定是黑色的空节点 v. 从根节点到任意一个叶子节点的路径中经过的黑色节点个数一致，即黑节点高度是一致的 vi. 新添的节点颜色一定是红的c. 修正： i. 涂色：父子节点为红，叔父节点为红，将父节点核叔父节点涂成黑色，然后将祖父节点涂成红色 ii. 左旋：父子节点为红，叔父节点为黑，且子节点是右子叶，那么以子节点为轴进行左旋 iii. 右旋：父子节点为红，叔父节点为黑，且子节点是左子叶，那么以父节点为轴进行右旋d. 红黑树的时间复杂度是O(logn) Callable定义： Callable是Java提供的一种定义线程的方式,在使用的时候通过泛型执行返回值类型 Callable和Runnable的区别 Runnable Callable 返回值 没有返回值 通过泛型来指定返回值的类型 启动方式 1. 通过Thread的start方法启动 2. 通过线程池的submit或者是execute方法执行 通过线程池的submit方法执行 容错机制 不允许抛出异常，所以不能利用全局方式(例如Spring中的异常通知)处理 允许抛出异常，所以可以利用切面或者是全局方式来处理异常 分叉合并池 Fork：分叉。将一个大任务拆分成多个小任务交给多个线程执行 Join：合并。将拆分出来的小任务的执行结果进行汇总 分叉合并的目的是为了提高CPU的利用率 在数据量相对小的时候，循环会比分叉合并快；数据量越大，分叉合并的优势越明显 分叉合并在进行的时候，导致其他程序的执行效率显著降低，所以分叉合并一般是在周末的凌晨来进行 分叉合并在分配子线程的时候，尽量做到每个核上的任务均匀：少的多分，多的少分 在分叉合并中，为了减少”慢任务”带来的效率降低，采取”work-stealing”(工作窃取)策略：当一个核将它的任务队列处理完成之后，这个核并不会闲下来，会随机扫描一个核，然后从被扫描核的任务队列尾端”偷取”一个任务回来执行 Lock - 锁概述 相对于synchronized更加灵活和精细 ReadWriteLock - 读写锁 a. 在使用的时候，需要用这个接口的实现类ReentrantReadWriteLock b. 在加锁的时候，需要先通过对应的方法来获取读锁或者写锁 公平和非公平策略 a. 非公平策略下，线程会直接抢占执行权，在资源有限的前提下，线程之间抢到的次数不一样 b. 公平策略下，线程不是直接抢占执行权，而是去抢占入队顺序。宪曾之间的执行次数是基本一致的 c. 默认情况下，使用的是非公平策略 d. 相对而言，非公平策略的效率会更高一些 其他 CountDownLatch：闭锁/线程递减锁。对线程进行计数，在计数归零之前会让线程陷入阻塞，直到计数归零才会放开阻塞 - 一波线程结束之后开启另一波线程 CyclicBarrier：栅栏。对线程进行计数，在计数归零之前让线程陷入阻塞，直到计数归零为止才会放开阻塞 - 线程到达同一个地点之后再分别执行 Exchanger：交换机。用于交换2个线程之间的信息 Semaphore：信号量。线程只有获取到信号之后才能执行，执行完成之后需要释放信号。如果所有的信号都被占用，那么后来的线程就会被阻塞","categories":[{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/categories/JUC/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"高并发基础","slug":"高并发基础","date":"2020-03-31T01:11:40.883Z","updated":"2020-04-01T01:08:18.732Z","comments":true,"path":"2020/03/31/高并发基础/","link":"","permalink":"http://yoursite.com/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本概念a. 同步：一个对象或者一段逻辑在一段时间只允许被一个线程访问b. 异步：一个对象或者一段逻辑在一段时间只允许被多个线程访问c. 阻塞：一个线程只要没有拿到想要的结果就会一直等在这儿d. 非阻塞：一个线程不管有没有拿到结果，都会继续执行下面的程序，不会在那边的等待 分类a. BIO ： 同步式阻塞线程b. NIO ： 同步式非阻塞式线程 JDK1.4c. AIO ： 异步式非阻塞式线程 JDK1.8，目前没有成熟的框架 BIO的缺点 一对一连接：每次有一个客户端发起连接，服务端就要产生一个线程来处理这个连接；如果有大量的客户端发起连接，就会产生大量的线程，可能导致服务端崩溃。 无效连接 如果客户端连接后不做任何操作但是一直保持连接，服务端的处理线程就不会释放，导致服务端 阻塞 效率低NIO三大组件Buffer-缓冲区 作用：存储数据 底层是基于数组来存储数据,针对基本数据类型，提供7个子类：ByteBuffer，ShortBuffer，InteBuffer，LongBuffer，FloatBuffer，DoubleBuffer，CharBuffer 重要位置a.capacity 容量位b.position 操作位c.limit 限制位d. mark 标记位4.重要操作反转缓冲区1234567//byteBuffer.flip(); public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this; &#125; clear清空缓冲区123456public final Buffer clear() &#123; position = 0; limit = capacity; mark = -1; return this; &#125; reset 重置缓冲区1234567public final Buffer reset() &#123; int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this; &#125; rewind 重绕缓冲区123456public final Buffer rewind() &#123; position = 0; mark = -1; return this; &#125; Channel 双向传输网路通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//client端public class client &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; //开启通道 SocketChannel sc = SocketChannel.open(); //手动设置非阻塞 sc.configureBlocking(false); //一旦设置为非阻塞，无论是否建立连接，都会往下执行 //发起连接，channel默认是阻塞的 sc.connect(new InetSocketAddress(\"localhost\",8100)); //判断是否建立连接 while (!sc.isConnected())&#123; //试图再次建立连接,这个方法会自动计数，如果多次建立无果，会自动抛出异常 sc.finishConnect(); &#125; //写出数据，都需要将数据以字节 sc.write(ByteBuffer.wrap(\"one world one dream\".getBytes())); ByteBuffer buffer = ByteBuffer.allocate(1024); Thread.sleep(10); sc.read(buffer); System.out.println(new java.lang.String(buffer.array(),0,buffer.position())); sc.close(); &#125;&#125;//sever端public class server &#123; public static void main(String[] args) throws IOException &#123; //开启通道 ServerSocketChannel ssc = ServerSocketChannel.open(); //绑定监听端口 ssc.bind(new InetSocketAddress(8100)); //手动设置非阻塞 ssc.configureBlocking(false); //无论是否建立连接 //接受连接 SocketChannel sc = ssc.accept(); while (sc==null)&#123; sc=ssc.accept(); &#125; //准备容器存储数据 ByteBuffer buffer = ByteBuffer.allocate(1024); sc.read(buffer); System.out.println(new String(buffer.array(),0,buffer.position())); sc.write(ByteBuffer.wrap(\"hello sever\".getBytes())); ssc.close(); &#125;&#125; Selector 多路复用选择器","categories":[{"name":"高并发","slug":"高并发","permalink":"http://yoursite.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"InterviewDay01","slug":"interview","date":"2020-03-18T15:48:06.390Z","updated":"2020-03-20T14:20:16.466Z","comments":true,"path":"2020/03/18/interview/","link":"","permalink":"http://yoursite.com/2020/03/18/interview/","excerpt":"","text":"1.volatile是什么？volatile是一种轻量级的同步机制volatile有三个特性： 可见性当多线程修改物理内存种的变量值时，会把内存中的变量值拷贝到各自的工作内存中，用volatile关键字修饰的变量，当一个线程在自己的工作内存中修改完成，写入物理内存后会通知其他线程数据已经修改，这就是可见性 不保证原子性在多线程都在实现如num++；可能回导致运算时加塞的情况，导致最后数据的不一致，这类可以用atomicInteger.getAndIncrement()实现原子性 禁止指令重拍为了性能的优化，jvm在不改变正确语义的前提下，会对代码的执行顺序进行优化，底层进行指令的重拍，在多线程的情况下可能导致数据的错误，加上volatile可以禁止指令重拍 Synchronized和Volatile的比较 1）Synchronized保证内存可见性和操作的原子性 2）Volatile只能保证内存可见性 3）Volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。） 4）volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）. 5）volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符。 volatile本质是在告诉JVM当前变量在寄存器中的值是不确定的，使用前，需要先从主存中读取，因此可以实现可见性。而对n=n+1,n++等操作时，volatile关键字将失效，不能起到像synchronized一样的线程同步（原子性）的效果。 单例模式在多线程环境下可能存在安全问题1234567891011121314151617//推荐使用双重检查,解决多线程单例模式的安全问题public class Singletlon &#123; private static Singtlelon instance =null; private Singtlon()&#123; &#125; public static Singtlelon getInstance()&#123; if(instance==null)&#123; synchronized(Singtlon.class)&#123; if(instance==null)&#123; instance=new Singletlon(); &#125; &#125; &#125; return instance; &#125;&#125; 2.CAS是什么？compare andswap 比较且交换在多线程的环境下，对数据惊醒修改，会将线程工作内存的数值与物理内存的期望值相比较如果相同就交换到更新值，返回true，如果不想等，则返回false底层主要是通过unsafe类来实现原子性 3. 底层是通过do while的自旋锁实现的，在多线程高并发的情况下，导致循环时间过长，引起cpu的开销很大只能保证一个变量的原子操作会导致ABA问题，只关心首尾的数值，忽略中间数值已经被修改过，这样会造成数据错乱的问题 如何解决ABA问题用AtomicStampedReference/AtomicMarkableReference原子引用解决ABA问题类似于版本控制，时间戳管控 集合类不安全之并发修改异常arraylist在多线程的情况下造成安全并发的问题，常见的异常ConcurrentModificationException 并发修改异常如何解决arraylist线程不安全的问题 使用vector代替arraylist，因为vector是线程安全的，底部在add方法上加入了synchronized同步锁 使用Collections集合工具类，调用Collections上的synchronizedList()这个方法可以解决arraylist线程不安全的问题 使用JUC下的CopyOnWriteArrayList这个类来解决线程不安全的问题,底层使用来lock锁来完成这一机制123456789101112131415161718192021public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125; &#125; HsahSet底层是HashMap，因为hashset的底层将value写成来一个最终常量，hashset存储数据不关心value值基本数据类型传值（相当于复制了一份） ，对象的引用是地址的传递（相当于指针）12String str =“aaa”//存储在常量池//会在常量池中找相应的值，有就找没有就会新建，注意内存的分析 公平锁和非公平锁公平锁：线程按照指定的顺序来占锁，按顺序执行非公平锁，允许其他线程加塞，上来就抢占锁，占不到按顺序执行。如synchronizedJava ReentrantLock 而言可以通过构造函数来指定是公平锁还是非公平锁，默认是非公平锁，如果参数列表指定true则为公平锁，非公平锁吞吐量比较大，执行效率高。 12345678910111213141516171819//无参构造/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */ public ReentrantLock() &#123; sync = new NonfairSync(); &#125;//含参构造/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */ public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; 可重入锁（ReentrantLock，递归锁）定义：线程可以进入任何一个它已经拥有的锁所同步着的代码块ReentrantLock and synchronized 是可重入锁，默认非公平，防止死锁，相当于用的是同一把锁 自旋锁定义：是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗cpu 独占锁ReentrantLock和synchronized该锁一次只能被一个线程所占有 共享锁多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。 读读可以共存 读写不可以共存 写写不可以共存","categories":[{"name":"Interview","slug":"Interview","permalink":"http://yoursite.com/categories/Interview/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"事务","slug":"事务","date":"2020-02-28T16:00:00.000Z","updated":"2020-02-29T03:09:41.839Z","comments":true,"path":"2020/02/29/事务/","link":"","permalink":"http://yoursite.com/2020/02/29/%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务逻辑上的一组操作，要么同时成功，要么同时失败 事务的四大特性（ACID） 原子性一个事务是一个不可分割的整体，要么同时成功，要么同时失败 一致性一个事务执行之前和之后数据也应该是完整的 隔离性多个并发的事务应该是独立的，互不影响的。 持久性事务一旦提交，事务对数据库的影响就真实发生了，无论做任何操作，这种影响无法被撤销。隔离性脏读：一个用户读取到另一个用户还未提交的数据，产生脏读不可重复读一个事务可以读取另一个事务已经提交的数据虚读（幻读）一个事务可以读取到另一个事务对整表数据增删改数据库事务的隔离级别read uncommited; - 读未提交 会出现脏读，不可重复读，虚读的问题read commited - 读已提交 可以防止脏读，repeatable red 可重复读 可以防止脏读和不可重复读serializable - 序列化 都可以避免，但效率低下锁机制 共享锁 共享锁和共享锁可以共存 共享锁和排他锁不能共存 排它锁 排他锁和共享锁不能共存 排他锁和排他锁不能共存","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"JavaSE04","slug":"JavaSE04","date":"2020-02-28T14:59:51.201Z","updated":"2020-02-28T14:59:51.201Z","comments":true,"path":"2020/02/28/JavaSE04/","link":"","permalink":"http://yoursite.com/2020/02/28/JavaSE04/","excerpt":"","text":"title: 线程date: 2020-02-28tags: - 分享 - 导航categories: Java基础– 程序为完成特定的任务，用某种语言编写一组指令的集合。一段静态的代码，静态对象 进程正在运行的程序 线程进程可以进一步细化为线程，是一个程序内部的执行路径 -","categories":[],"tags":[]},{"title":"JavaSE03","slug":"JavaSE03","date":"2020-02-28T13:02:22.563Z","updated":"2020-02-28T13:02:22.563Z","comments":true,"path":"2020/02/28/JavaSE03/","link":"","permalink":"http://yoursite.com/2020/02/28/JavaSE03/","excerpt":"","text":"title: Collection(集合)date: 2020-02-28tags: - 分享 - 导航categories: Java基础– 泛型泛型的本质是数据类型的参数化，在编译器阶段处理 -","categories":[],"tags":[]},{"title":"JVMDay01","slug":"JVM","date":"2020-02-27T16:00:00.000Z","updated":"2020-03-18T01:18:51.485Z","comments":true,"path":"2020/02/28/JVM/","link":"","permalink":"http://yoursite.com/2020/02/28/JVM/","excerpt":"","text":"","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"JavaSE01","slug":"JavaSE01","date":"2020-02-25T16:00:00.000Z","updated":"2020-02-26T13:35:16.531Z","comments":true,"path":"2020/02/26/JavaSE01/","link":"","permalink":"http://yoursite.com/2020/02/26/JavaSE01/","excerpt":"","text":"1. 简单说一下什么是跨平台由于各种系统所支持的指令集不是完全一致，所以在操作系统上加个虚拟机可以来提供统一的接口，屏蔽系统之间的差异。2.Java有几种基本数据类型8种基本数据类型数据类型 字节 默认值 byte 1 0 short 2 0 int 4 0 long 8 0 double 4 0.0d float 8 0.0f char 2 ‘\\u0000’ boolean 1 false 3.面向对象的特征 封装 把描述一个对象的属性和行为封装在一个模块中，也就是封装到一个类中，用变量来定义对象的属性，用方法来定义对象的行为，方法可以直接访问同一对象的属性 继承 发生在父子类中，子类可以继承父类的特征和行为，子类继承父类的非private修饰的方法，子类也可以对父类的方法进行重写，缺点是增加了代码之间的耦合性 多态 不同子类型的对象对同一消息作出不同的响应分为编译时多态和运行时多态编译时多态：常见的方法的重载，也就是一个类中存在多个方法名相同，而参数列表不同的方法运行时多态 方法的重写实现的是运行时多态，重写指的是子类重写父类的方法，重写的原则是，子类和父类的方法签名相同，也就是子类方法的返回值类型，方法的参数列表，以及方法名要与父类方法相同，子类抛出的异常小于等于父类抛出的异常，子类方法的访问修饰权限要&gt;=父类的访问修饰符权限，向上造型：用父类型引用子类型对象，这样调用同样的方法就会根据子类对象的不同而表现出不一样的行为。 抽象抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有那些属性和行为，并不关注这些行为的细节是什么？ 4.为什么要有包装类型让基本数据类型也具有对象的特征。jdk1.5的新的性自动装箱：Integer i = 1 ; 把基本数据类型转化为包装类，底层用的Integer.valueof(1)自动拆箱：int i =new Integer(6) 把包装类型转化为基本数据类型 i.intValue(); 二者的区别： 声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字在堆中分配内存 存储方式及位置不同：基本类型是直接将变量存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 初始值不同：基本类型的初始值为0，boolean为false，而包装类型的初始值为null 使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Interface(接口）","slug":"JavaSE02","date":"2020-02-25T16:00:00.000Z","updated":"2020-02-28T12:27:41.878Z","comments":true,"path":"2020/02/26/JavaSE02/","link":"","permalink":"http://yoursite.com/2020/02/26/JavaSE02/","excerpt":"","text":"抽象类和抽象方法抽象类：如果一个类中有一个或多个抽象方法，那么这个类必须是抽象类。 抽象类不能创建对象，因为抽象类创建对象没有意义,但可以创建抽象类的子类对象 子类继承抽象类需要重写抽象类中的抽象方法，如果不重写这个类必须是抽象类，否则会产生编译时异常 抽象类中可以没有抽象方法, 可以向上造型，引用父类类型创建子类对象，调用子类方法 abstract和static不能同时使用###抽象方法：没有方法体的方法，用abstract关键字修饰接口 interface关键字修饰，产生一个完全的抽象类，接口中的方法都是抽象方法，接口也不能被实例化 在接口中定义的方法必须被public修饰，而抽象类中的方法可以被其他访问权限修饰符修饰，如果不写java默认会用public修饰 接口中的变量默认被static和final关键字修饰，可以直接被接口名调用，不能被修改","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"LinuxDay03","slug":"LinuxDay03","date":"2020-02-25T10:45:09.000Z","updated":"2020-02-25T13:53:45.484Z","comments":true,"path":"2020/02/25/LinuxDay03/","link":"","permalink":"http://yoursite.com/2020/02/25/LinuxDay03/","excerpt":"","text":"网络地址配置网络的时候需要配置下面的信息 IP地址：PC在网络中的通信地址 子网掩码: 子网掩码用于划分网络，将一个IP地址中的网络位和主机位进行划分。是一个32位的地址。 网关： 网络的关口，用于数据转发，通常理解为路由器的地址，大部分硬件厂家默认地址，192.168.0.1 |192.168.1.1 DNS: 用于解析域名的作用，Domain Name System 域名解析系统DNS静态优点：可以是我们PC/服务器有一个更快的解析速度。维护方式手动配置hosts文件，配置ip和域名的映射缺点：hosts一般都是为本机系统所有，维护上万台的服务器的集群很困难动态优点：只需要给服务器指明DNS服务器地址即可，无需手动配置hosts文件缺点：有一定的响应时间（延迟），若DNS服务器党机，那么此域名就没有办法访问桥接模式和NAT模式的优缺点桥接模式：优点：同一个局域网中任意一台物理机想要访问虚拟机时，只要拥有账户和密码，就可以直接进行通信缺点：如果宿主主机没有连接网络，那么虚拟机也就不存在与该真实网络的环境中，换句话，虚拟机使用桥接模式的时候，它的网络依赖于宿主的网络的环境。NAT优点：可以无视物理机网络环境，即便时物理机没有网络，也不影响本机和虚拟机进行通信。因为虚拟机真正通信网卡是VMNet8提供（网络环境）缺点：其他物理机想要访问NAT模式下的虚拟机时，比较麻烦Linux的网络知识通过域名查看IP host www.baidu.com远程拷贝本机与Linux之间的文件传输，在本机的控制台上,本机的文件的路径为绝对路径例如：本机传送文件到Linux中 命令：scp /Users/yuxiangrui/Desktop/1.jpg root@192.168.144.134:/home/ 本机传送文件夹，命令：scp -r /Users/yuxiangrui/Desktop/1.jpg root@192.168.143.134 linux中传送文件到本机 scp root@92.168.143.134：/home/1.jpg /Users/yuxiangrui/Desktop/ linux中传送文件夹到本机 scp -r root@92.168.143.134：/home/1.jpg /Users/yuxiangrui/Desktop/登陆远程服务器 ssh root@192.168.143.134SSH免密登陆Linux免密登陆使用的RSA算法 RSA本身是一种非对称加密算法，会生成公钥和私钥生成密钥 ssh-keygen这样.ssh目录下就会有公钥和私钥的文件 将公钥注册到其他服务器上ssh-copy-id {UserName}@IPwget wget http://www.baidu.com查看进程ps -aux查询特定的进程ps -aux｜grep sshd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"LinuxDay02","slug":"LinuxDay02","date":"2020-02-24T11:07:09.000Z","updated":"2020-02-24T14:06:52.707Z","comments":true,"path":"2020/02/24/LinuxDay02/","link":"","permalink":"http://yoursite.com/2020/02/24/LinuxDay02/","excerpt":"","text":"用户、用户组概念Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户都必须首先向系统管理员申请账号，然后以这个账号的身份进入系统。用户在登陆时建入正确的用户名和口令后，就能够进入系统和自己的主目录。用户管理&gt; &gt;&gt; 用法ls -l &gt; a.txt 把显示的内容覆盖写入a.txt，如果没有这个文件则创建此文件 追加，例如ls -l &gt;&gt; a.txt把当前显示的内容追加到a.txt的末尾。 echo输出打印 echo “hello” head显示文件的前10行head -n 10 /etc/peofile tailtail -n 5 /etc/profile 查看文件的后5行tail -f 实时监控文件是否变化 chmod 修改用户的权限4:可读 2:可写 1:可执行0:没有任何权限 设定用户权限可读可写可执行，用户组全前线可读可执行 其他没有权限 chmod 750 文件or文件夹 usermod 将用户加入用户组usermod -g A zhangsan 将张三加入A组中 chown 修改文件目录属主chown root：big A 将A的属主改成big","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Web总结","slug":"Web","date":"2020-02-20T16:00:00.000Z","updated":"2020-02-23T06:42:58.702Z","comments":true,"path":"2020/02/21/Web/","link":"","permalink":"http://yoursite.com/2020/02/21/Web/","excerpt":"","text":"AJAX 背景 web开发是通过HTTP协议实现的 Http协议的特点： a. 基于请求相应模型 b. 一次请求对应一次响应 c. 请求只能由客户端发出，服务器端只能被动等待请求作出响应基于这样的特点，网站只能实现同步请求，全部刷新的效果，但实际生活中需要在不影响正在展示的内容的情况下还要保证服务器不停的向客户端发送最新的数据，这只靠HTTP协议无法完成，所以AJAX的技术应运而生。 特点 AJAX技术实现：异步请求，局部刷新。AJAX不是一项新的技术，而是多个已有的技术整合实现的，其原理就是在页面的js中通过代码在不影响当前页面的情况下向服务器发送请求，得到服务器传递的最新数据后再通过js更新当前页面的局部内容。 AJAX仍然是基于HTTP协议，没有违背HTTP协议的原理 jquery方式实现AJAX a. 通用方式12345678910function getTime() &#123; $.ajax(&#123; type:&quot;post&quot;, url:&quot;&#x2F;ExecDemo01_war_exploded&#x2F;TimeServlet&quot;, data:&quot;&quot;, success: function (msg) &#123; $(&quot;#d01&quot;).text(msg) &#125; &#125;) &#125; b. get方式1234567&#x2F;*get方式*&#x2F; function getTime1()&#123; $.get(&quot;&#x2F;ExecDemo01_war_exploded&#x2F;TimeServlet&quot;,function (msg) &#123; $(&quot;#d01&quot;).text(msg) &#125;) &#125; c. post方式1234567&#x2F;*post方式*&#x2F; function getTime2()&#123; $.post(&quot;&#x2F;ExecDemo01_war_exploded&#x2F;TimeServlet&quot;,function (msg) &#123; $(&quot;#d01&quot;).text(msg) &#125;) &#125; d. getJSON方式123456&#x2F;*getJSON方式*&#x2F; function getTime3()&#123; $.getJSON(&quot;&#x2F;ExecDemo01_war_exploded&#x2F;TimeServlet&quot;,function (obj) &#123; $(&quot;#d01&quot;).text(obj.time) &#125;) &#125; HTTP协议 概述 基于TCP协议的应用层协议。 是客户端的和服务器通信的常用协议。 规则 a. 基本规则 基于请求响应模型 一次请求对应一次响应 请求只能由客户端发出，服务器端被动接受请求作出响应 请求： 一个请求行 GET /index.html HTTP/1.1 请求方式 请求方式（8种），最常见的是GET和POST请求 8种请求方式：opions get post put head delete trace connect GET请求：请求参数在地址栏上拼接，相对安全性较差传输的数据量有限 POST请求：请求参数在实体内容中传输，相对安全性较高，传输的数据量理论上没有限制。请求的资源地址 使用的协议版本 1.0 每次请求都要重新创建连接，完成请求响应断开连接，效率低 1.1 在一次请求响应结束后，可以选择保持底层连接，如果后续请求到来可以复用底层连接，效率高请求头： Accept：浏览器可以接受的MIME类型 Accept-Charset：浏览器可接受的字符集 Accept-Encoding：浏览器能够进行解码的数据编码方式，比如说gzip，Servlet能够向支持的gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10被的下&gt;载的时间Accept-Language:浏览器可以接受的语言种类 Connection：表示是否需要持久连接，HTTP默认KeepAlive Content-Length：表示请求消息正文的长度 Cookie：存放缓存信息 Host：初始URL中的主机和端口 If-Modified—Since：只有当所请求的内容在指定的日期之后又经过修改才返回他&gt;，否则返回304NotModified Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用； 一个空白行 存在的目的是将请求头和实体内容分割开实体内容 要向服务器传递数据 GET提交时，实体内容为空，post提交时，请求参数在实体内容中传输HTTP协议只支持ISO8859-1（Latin1）编码，此编码集只有英文数字常见的符号，所以必须要通过URL解决乱码问题 c.响应 一个状态行 HTTP/1.1200 ok 使用的协议 状态码 1XX 临时响应 2XX 成功 200成功 3XX 重定向 302重定向304/307使用缓存 4XX 请求错误 找不到资源 5XX 服务器错误 500服务器错误","categories":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/categories/Web/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"LinuxDay01","slug":"LinuxDay01","date":"2020-02-20T14:08:06.604Z","updated":"2020-02-20T14:08:06.604Z","comments":true,"path":"2020/02/20/LinuxDay01/","link":"","permalink":"http://yoursite.com/2020/02/20/LinuxDay01/","excerpt":"","text":"Linux简介Linux是一款操作系统，它是由unix演变而来的，创始人是芬兰当时的大学生肯.汤普森写的一款操作系统，Linux具有开源免费的特点，现在广泛运用于服务器端。 Linux的优势相较于Windows而言Linux更加的安全，更加的高效,对网络有良好的支持性，稳定，低成本，可以很好的解决多并发的问题。 2.创建虚拟机（空间）#### 配置网络连接时有三种形式： 1.桥连接：Linux可以和任意系统进行通信，但是可能造成ip冲突的问题 2.NAT：网络地址的转化方式，linux可以访问外网但外网不可以直接访问Linux 3.主机模式：Linux是独立的主机不可以访问外网 3.Linux的目录结构Linux的文件是采用级层式的树状目录，在此结构中的最上层是根目录“/”,然后在&gt;此目录下再创建其他的目录 $\\color{#FF0000}{在linux的世界里，一切皆文件}$常见的命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"MyBatisDay01","slug":"MyBatisDay01","date":"2020-02-06T11:29:59.000Z","updated":"2020-02-19T13:49:44.974Z","comments":true,"path":"2020/02/06/MyBatisDay01/","link":"","permalink":"http://yoursite.com/2020/02/06/MyBatisDay01/","excerpt":"","text":"mybatis的概述mybatis是一个数据访问层的框架，用java编写的。 它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等复杂过程，是一种半自动对象表的Dao层框架 它使用了ORM思想实现了结果集的封装。优点可以手写sql灵活实现数据访问，自动封装数据，减少代码的冗余ORM思想：Object Relational Mapping （对象关系映射）","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"工厂模式","slug":"工厂模式","date":"2020-02-01T12:30:09.000Z","updated":"2020-02-03T08:39:22.722Z","comments":true,"path":"2020/02/01/工厂模式/","link":"","permalink":"http://yoursite.com/2020/02/01/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式定义：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Design Patterns","slug":"Design-Patterns","date":"2020-01-31T04:53:50.000Z","updated":"2020-02-01T10:13:04.969Z","comments":true,"path":"2020/01/31/Design-Patterns/","link":"","permalink":"http://yoursite.com/2020/01/31/Design-Patterns/","excerpt":"","text":"设计模式的类型设计模式分为三种类型，共23种 创建型模式：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。 结构型模式：适配器模式，装饰者模式，桥接模式，组合模式，外观模式，享元模式，代理模式 行为型模式：模版方法模式，命令模式，访问者模式，迭代器模式，观察者模式，备忘录模式，解释器模式（interpreter模式），状态模式，策略模式，职责链模式（责任链）模式。设计模式常用的七大原则1.单一职责原则 降低类的复杂度，一个类只负责一项职责 便于后期的代码的维护，提高代码的刻度性 降低后期因变更而引起的风险 通常情况下我们应该遵循单一职责原则，但在一个类中方法较少的时候，我们可以在方法的级别保持单一职责原则即可 2. 接口隔离原则 一个类通过接口依赖另一个类，该接口应该是最小接口，也就是通过接口的隔离保证类中不需要接口中多余的方法，如果接口中有用不到的方法，就把这个接口中拆分成多个小接口，避免造成浪费。 3. 依赖倒转原则（Dependence Inversion Principle）案例12345678910111213141516171819202122232425262728293031323334public class DependcyIversion &#123; public static void main(String[] args) &#123; Person person = new Person(); person.receive(new Email()); person.receive(new Weixin()); &#125;&#125;interface Ireceiver &#123; String getInfo();&#125;class Email implements Ireceiver &#123; @Override public String getInfo() &#123; return \"hello world\"; &#125;&#125;class Weixin implements Ireceiver &#123; @Override public String getInfo() &#123; return \"one world,one dream\"; &#125;&#125;class Person &#123; public void receive(Ireceiver ireceiver) &#123; System.out.println(ireceiver.getInfo()); &#125;&#125;//总结：通过类与接口发生依赖，与子实现类没有关系，这样便于后期的修改，这就是面向接口编程的思想 低层模块最好是抽象类或者接口，这样程序会更稳定 变量声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利用程序扩展和优化 继承时遵循里氏替换原则 4. 里氏替换原则 继承增加了程序的耦合性 子类尽量不要重写父类的方法，如果需要重写，就通过依赖，组合，聚合的方法，提升一个基类，让原有的父类和子类继承这个基类案例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(\"11-3=\" + a.fun1(11, 3)); System.out.println(\"1-8=\" + a.fun1(1, 8)); System.out.println(\"-----------\"); B b = new B(); System.out.println(\"11+3=\" + b.fun1(11, 3)); System.out.println(\"1+8=\" + b.fun1(1, 8)); System.out.println(\"11+3+9=\" + b.fun2(11, 3)); System.out.println(\"11-3=\" + b.fun3(11, 3)); &#125;&#125;class Base &#123;&#125;class A extends Base &#123; public int fun1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;//B类继承了A//增加了一个新功能：完成两个数相加，然后和9求和class B extends Base &#123; //通过依赖的方式与类A发生关系 private A a = new A(); public int fun1(int a, int b) &#123; return a + b; &#125; public int fun2(int a, int b) &#123; return fun1(a, b) + 9; &#125; public int fun3(int a, int b) &#123; return this.a.fun1(a, b); &#125;&#125; 5. 开闭原则 ocp(open closed principle) 是编程中最基础，最重要的设计原则6. 迪米特法则（最少知道原则） 降低类之间的耦合，对自己依赖的类知道的越少越好 降低类间（对象间）耦合关系，并不是要求完全没有依赖关系 直接朋友，出现在成员变量，方法参数，方法返回值，如果出现在局部变量中则是陌生朋友7. 合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo1 &#123; @Test public void test()&#123; Dog d = new Dog(); d.setAnimal(); &#125;&#125;class Animal &#123; void run()&#123; System.out.println(\"正在跑\"); &#125; void sleep()&#123; System.out.println(\"正在睡\"); &#125; void eat()&#123; System.out.println(\"正在吃\"); &#125;&#125;//方式一依赖/*class Dog &#123; public void action(Animal animal)&#123; animal.run(); animal.eat(); &#125;&#125;*///方式二聚合/*class Dog &#123; private Animal animal; public void setAnimal(Animal animal)&#123; animal.eat(); &#125;&#125;*///方式三：组合class Dog &#123; private Animal animal = new Animal(); public void setAnimal() &#123; animal.eat(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringCloud","slug":"SpringCloud","date":"2020-01-29T04:22:20.000Z","updated":"2020-04-07T01:43:51.737Z","comments":true,"path":"2020/01/29/SpringCloud/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringCloud/","excerpt":"","text":"1.微服务1.1 单体项目：所有的功能都集中在一个web项目中。容易造成功能的强耦合1.2 由于单体项目本身具有强耦合的问题，所以需要对项目进行拆分 a.横向拆分目的：仅仅解决了一个项目的分布式，并行开发的问题，必能解决单体项目的各种问题b.纵向拆分目的：将一个运行的系统，变成多个独立运行的系统，可以解觉单体项目的问题？按照业务功能，领域不同，进行的划分，每一个划分出来的系统都可以独立运行Springcloud组件功能 springcloud概括是spring家族的一员，本身也是一批不同组件的集合框架。在微服务发展过程中，不同的公司，团队各自开发了不同的小的功能。spring创建框架时，采用一种整合的方式，将一些成熟的技术，兼容到框架来，行程一个庞大的集体 1.1组件 eureka:服务治理(动态微服务信息维护组件） ribbon：负载均衡客户端（负载均衡调用微服务组件） zuul:网关组件（每一个微服务不能提供对外暴露的接口）上述这3个组件就能开发出一个基本的微服务框架的项目 config：分布式配置中心 feign:负载均衡客户端 eureka服务治理组件 2.1eureka概括 作为服务治理组件，是每个微服务框架必备的组件。实现动态管理和维护所有微服 务信息。springcloud只能使用eureka作为服务治理组件，通过http协议的REST风 格实现通信过程（已经定义好了所有访问这个组件的接口地址，url：/hello/ /abc/cs）。","categories":[{"name":"微服务","slug":"微服务","permalink":"http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Shell","slug":"Shell","date":"2020-01-29T04:22:20.000Z","updated":"2020-04-07T01:42:33.317Z","comments":true,"path":"2020/01/29/Shell/","link":"","permalink":"http://yoursite.com/2020/01/29/Shell/","excerpt":"","text":"Shell传递参数值123456#!&#x2F;bin&#x2F;bashecho &quot;Shell 传递参数实例&quot;echo &quot;执行的文件名：$0&quot;echo &quot;第一个参数为：$1&quot;echo &quot;第二个参数为：$2&quot;echo &quot;第三个参数为：$3&quot; Shell $*和$@的演示123456789#!&#x2F;bin&#x2F;bashecho &quot;--\\$*演示---&quot;for i in &quot;$*&quot; ;do echo $idoneecho &quot;--\\$@演示---&quot;for i in &quot;$@&quot; ;do echo $idone Shell的基础命令（find）查找文件的位置 find 位置 选项 参数 例如：按文件名进行查询 find / -name java 查找当前系统中所有的.log后缀名的文件 find / -name “*.log” 查找系统中/home目录下的非普通文件 find /home ! -type f 查找/home目录下权限为700的文件 find /home -perm 700 查找/dev目录下的块设备文件 find /dev -type b","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringMVCDay01","slug":"MyBatisday02","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-17T13:52:02.540Z","comments":true,"path":"2020/01/29/MyBatisday02/","link":"","permalink":"http://yoursite.com/2020/01/29/MyBatisday02/","excerpt":"","text":"1.SpringMVC概述SpringMVC是一个WEB层，控制层框架，主要用来负责与客户端交互，业务逻辑的调用。SpringMVC是Spring家族的一大组件，Spring整合SpringMVC可以做到无缝集成，特点：简单易用性能佳2.SpringMVC相对与Servlet的优势a. Servlet的开发配置相对麻烦，servlet特别多的时候web.xml文件将会非常的臃肿b. 每个Servlet都只能处理一个功能，如果需要多个功能就需要开发多个servlet，项目中存在大量的servlet显得臃肿。c. 获取请求参数进行类型转换封装数据到bean的过程比较繁琐。d. 其他开发中不方便的地方，例如乱码问题，数据格式处理，表单检索 spring MVC详解 SpringMVC的组件a. 前端控制器（DispatcherServlet） 本质上是一个servlet，相当于一个中转站，所有的访问都会走到这个servlet中，再根据配置进行中转到相对应的handler中进行处理，获取数据和视图b. 处理器映射器（HandlerMapping） 本质上就是一段映射关系，将将访问路径和对应的Handler存储为映射关系，在需要时供前端控制器查阅。c. 处理器适配器（HandlerAdapter） 本质上就是一个适配器，可以根据要求找到对应的handler来运行。前端控制器找到处理器映射器找到对应的handler信息之后，将请求响应和对应的handler信息交由处理器适配器来处理，处理器适配器找到真正的handler执行后，将结果也就是model and view返回给前端控制器。d. 视图解析器（ViewResolver） 本质上是一种映射关系，可以将视图名称映射到真正的视图地址。前端控制器调用处理器适配完成后的到model和view，将view信息传给视图解析器得到真正的view。e. 视图（view） 本质上就是将handler处理器中返回的model数据嵌入到视图解析后得到的jsp页面中，向客户端作出响应生成SpringMvc的核心配置文件1234567891011121314&lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--手动配置核心文件的位置--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 1234567&lt;!--配置处理器映射器中的路径和处理器的映射关系--&gt; &lt;bean name=\"/hello.action\" class=\"cn.tedu.web.Hello\"&gt;&lt;/bean&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 123456789101112131415//创建类实现controller接口public class Hello implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //创建modelAndView ModelAndView modelAndView = new ModelAndView(); //封装数据 modelAndView.addObject(\"msg1\",\"hello world\"); modelAndView.addObject(\"msg2\",\"hello springMVC\"); //封装视图 modelAndView.setViewName(\"hello\"); //返回modelAndView return modelAndView; &#125;&#125; SpringMVC注解方式配置 SpringMVC支持使用注解方式配置，比配置文件更加的灵活易用，是目前的主流配置方式1234567&lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--配置视图解析器中视图名称和真正页面的映射关系--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 1234567891011121314&lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--手动配置核心文件的位置--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 123456789@RequestMapping(\"/my01\")@Controllerpublic class Controller01 &#123; @RequestMapping(\"/test01.action\") public String test01(Model model)&#123; model.addAttribute(\"msg\",\"one word one dream\"); return \"test01\"; &#125;&#125; springMVC注解工作原理 当服务器启动时，会先加载web.xml文件，之后通过引入核心配置文件来加载SpringMVC.xml 当解析到包扫描时，扫描指定的包，并将含有@Conteoller注解的类解析为处理器 如果配置过mvc:annotation-driven就会解析Spring-MVC注解 解析@requestMapping（value=“/test01.action”），将指定的地址和当前方法的映射关系保存 当客户端发出请求访问时，SpringMVC寻找改地址的映射关系，找到就执行方法，找不到抛出404 SpringMVC获取请求参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@Controllerpublic class MyController01 &#123; /** * 获取请求参数：日期数据处理 * 通过注册自定义类型编辑器使SpringMVC支持自定义格式请求参数的处理 * 此处，SpringMVC为Date类型已经提供了编辑器类，所以直接使用，不用自己写 * http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01test09.jsp */ @InitBinder public void myInitBinder(ServletRequestDataBinder dataBinder)&#123; dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat(\"yyyy-MM-dd\"),true)); &#125; @RequestMapping(\"/test09.action\") public void test09(String name, int age, Date birthday) &#123; System.out.println(name); System.out.println(age); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); String format1 = format.format(birthday); System.out.println(format1); &#125; /** * 获取请求参数：中文乱码解决 * 如果服务器配置的编码是utf-8,且项目采用的也是utf-8则默认请求参数无乱码 * tomcat8默认编码为utf-8(可以更改) * tomcat7及更老的版本默认编码为iso8859-1(可以更改) * 如果遇到服务器编码和项目编码不一致时会产生乱码 * 对于POST提交 可以通过request.setCharacterEncoding(\"utf-8\")解决乱码 * 但此行代码对GET无效，GET提交的请求参数乱码，只能手工编解码来解决 * 手工编解码解决乱码的方式对POST提交也有效 * springmvc提供了过滤器CharacterEncodingFilter来帮助我们解决乱码 * 但此过滤器本质上就是request.setCharacterEncoing()所以也是只对POST有效 * ,即使配置了GET提交乱码也要手动解决 * */ @RequestMapping(\"/test08.action\") public void test08(HttpServletRequest request) throws UnsupportedEncodingException &#123; //POST提交 //request.setCharacterEncoding(\"utf-8\"); //String uname = request.getParameter(\"uname\"); //System.out.println(uname); //GET提交 //String uname = request.getParameter(\"uname\"); //byte [] data = uname.getBytes(\"iso8859-1\"); //uname = new String(data,\"utf-8\"); //System.out.println(uname); &#125; // 获取请求参数：多个同名请求参数的处理 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test07.action?name=tt&amp;love=bb&amp;love=pp&amp;love=zz @RequestMapping(\"/test07.action\") public void test07(String name,String [] love) &#123; //封装到数组里 System.out.println(name); System.out.println(Arrays.asList(love)); &#125; //获取请求参数：自动封装请求参数到bean 对复杂类型的处理 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test06.action?id=35&amp;name=jj&amp;age=18&amp;addr=cd&amp;dog.name=wd&amp;dog.age=1&amp;dog.cat.name=xx&amp;dog.cat.age=3 @RequestMapping(\"/test06.action\") public void test06(User user) &#123; System.out.println(user); &#125; //获取请求参数：自动封装请求参数到bean 对复杂类型的处理 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test05.action?id=35&amp;name=jj&amp;age=18&amp;addr=cd&amp;dog.name=wd&amp;dog.age=1 @RequestMapping(\"/test05.action\") public void test05(User user) &#123; System.out.println(user); &#125; //获取请求参数：自动封装请求参数到bean // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test04.action?id=35&amp;name=jj&amp;age=18&amp;addr=cd @RequestMapping(\"/test04.action\") public void test04(User user) &#123; System.out.println(user); &#125; //获取请求参数: 通过@RequestParam指定参数赋值,解决请求参数名和方法参数不一致时赋值问题 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test03.action?name=yasuo&amp;uage=19 @RequestMapping(\"/test03.action\") public void test03(@RequestParam(\"name\") String username, @RequestParam(\"uage\") int age) &#123; System.out.println(username + \"~~~~\" + age); &#125; //获取请求参数: 直接获取 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test02.action?username=yasuo&amp;age=19 @RequestMapping(\"/test02.action\") public void test02(String username, int age) &#123; System.out.println(username + \"~~~~\" + age); &#125; //获取请求参数：传统方式获取 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test01.action?username=yasuo&amp;age=19 @RequestMapping(\"/test01.action\") public void test01(HttpServletRequest request) &#123; String username = request.getParameter(\"username\"); int age = Integer.parseInt(request.getParameter(\"age\")); System.out.println(username + \"~~~~\" + age); &#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringDay01","slug":"SpringDay01","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T09:18:51.390Z","comments":true,"path":"2020/01/29/SpringDay01/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay01/","excerpt":"","text":"框架（半成品软件）高度抽取可重用代码的一种设计，高度的通用性; 框架：抽取成一种高度可重用的；事务控制，强大的servlet，项目中的一些工具。 框架：多个可重用模块的集合，形成一个某个领域的整体解决方案；常见的框架SSH（老三大框架）Struts2 Spring HibernateSSM（新三大框架）SpringMVC(WEB) Spring（Service） Mybatis（Dao） Spring 框架Spring是一个service层的框架，可以整合其他框架 容器（可以管理所有的组件（类））框架；核心关注：IOC和AOPIOC：- 控制反转 AOP：- 面向切面编程案例一第一步:先导入jar包 第二步:配置Spring容器约束文件 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"person01\" class=\"cn.tedu.domain.Person01\"&gt;&lt;/bean&gt; &lt;bean id=\"person02\" class=\"cn.tedu.domain.Person01\"&gt;&lt;/bean&gt;&lt;/beans&gt; 案例一1234567891011121314151617181920212223242526272829303132333435363738394041/* spring 容器底层默认通过读取配置文件的类的全路径名，通过反射来创建对象* 并保存到Spring容器的Map内存中并且通过键值对的形式储存，降低了程序的耦合性* 通过getbean方法容器中找到匹配的键值对，来创建实例，多次获取同一个id的实例是同一个实例*/public class Test01 &#123; @Test public void test01()&#123; //初始化容器,ApplicationContext是接口创建实现类对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\"); //获取bean，获得对象 Person01 p = (Person01) context.getBean(\"person01\"); //调用p的方法 p.eat(); p.sleep(); System.out.println(p); //关闭容器 ((ClassPathXmlApplicationContext) context).close(); &#125; //如果配置文件中包含两个id则会抛出异常 BeanDefinitionParsingException, // 这是因为Spring容器在存储对象时默认以键值对的形式存储的不能出现相同的key值 @Test public void test02()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 p = (Person01) context.getBean(\"person01\"); System.out.println(p); &#125; /* * Spring容器中可以包含相同的class属性，对应不同的id,且获取的是不同的实例*/ @Test public void test03()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 p1 = (Person01) context.getBean(\"person01\"); Person01 p2 = (Person01) context.getBean(\"person02\"); System.out.println(p1);//cn.tedu.domain.Person01@6e0e048a System.out.println(p2);//cn.tedu.domain.Person01@5bc79255 //关闭资源 ((ClassPathXmlApplicationContext) context).close(); &#125;&#125; 案例二：创建bean的方式123456789101112131415161718192021222324252627282930313233//创建bean /* * Spring中默认是调用类的无参构造构造,通过反射来创建bean的 * 如果没有无参构造构造就不能直接配置类的全路径名获得bean*/ //Spring创建bean，没有无参构造构造，默认创建失败public class Test04 &#123; //java.lang.NoSuchMethodException:没有默认的无参构造 @Test public void test01()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 p = (Person01) context.getBean(\"person01\"); System.out.println(p); &#125; //通过反射创建对象 //java.lang.InstantiationException: cn.tedu.domain.Person01 //直接用clz.newstance,默认调用无参构造但只有含参数构造会抛出异常 // Caused by: java.lang.NoSuchMethodException: cn.tedu.domain.Person01.&lt;init&gt;() @Test public void test02() throws Exception &#123; Class&lt;?&gt; clz = Class.forName(\"cn.tedu.domain.Person01\"); Constructor&lt;?&gt; constructor = clz.getConstructor(String.class); Person01 p = (Person01) constructor.newInstance(\"reason\"); System.out.println(p);//cn.tedu.domain.Person01@1edf1c96 &#125; //普通方法创建对象 @Test public void test03()&#123; Person01 person01 = new Person01(\"xx\"); System.out.println(person01); &#125;&#125; 案例三：利用工厂获取bean1. 静态工厂1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置静态工厂--&gt; &lt;bean id=\"person01\" class=\"cn.tedu.factory.Person01StaticFactory\" factory-method=\"getInstance\"&gt;&lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718//创建静态工厂public class Person01StaticFactory &#123; //私有化构造方法，不让外界随意的创建对象 private Person01StaticFactory()&#123; &#125; //对外界提供公共的静态的getInstance的方法 public static Person01 getInstance()&#123; return new Person01(\"reason\"); &#125;&#125;//测试静态工厂 @Test public void test05()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 person01 = (Person01) context.getBean(\"person01\"); System.out.println(person01);//cn.tedu.domain.Person01@3b084709 &#125; 2. 实例工厂12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置实例工厂--&gt; &lt;bean id=\"person01InstanceFactory\" class=\"cn.tedu.factory.Person01InstanceFactory\" &gt;&lt;/bean&gt; &lt;bean id=\"person01\" factory-bean=\"person01InstanceFactory\" factory-method=\"getInstance\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345678910111213//创建实例工厂public class Person01InstanceFactory &#123; public Person01 getInstance()&#123; return new Person01(\"xx\"); &#125;&#125;//测试实例工厂@Test public void test06()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); Person01 person01 = (Person01) context.getBean(\"person01\"); System.out.println(person01);//cn.tedu.domain.Person01@3b084709 &#125; 3. Spring工厂1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!--配置Spring工厂--&gt; &lt;bean id=\"person01\" class=\"cn.tedu.factory.Person01SpringFactory\"&gt;&lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627//创建SpringFactory需要实现FactoryBean接口指定泛型为获取实例的泛型public class Person01SpringFactory implements FactoryBean&lt;Person01&gt; &#123; @Override public Person01 getObject() throws Exception &#123; //返回person01实例 return new Person01(\"xx\"); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; //返回实例的class对象 return Person01.class; &#125; @Override public boolean isSingleton() &#123; //是否是单例，Spring默认全局只有一个实例 return true; &#125;&#125;//测试Spring工厂 @Test public void test07()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext2.xml\"); Person01 person01 = (Person01) context.getBean(\"person01\"); System.out.println(person01);//cn.tedu.domain.Person01@23e028a9 &#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringDay04","slug":"SpringDay04","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T11:54:50.871Z","comments":true,"path":"2020/01/29/SpringDay04/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay04/","excerpt":"","text":"SpringAOP1. Spring aop的基本概念连接点 连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。 通俗讲： 层与层之间方法调用的过程称之为连接点 切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心。核心：Spring缺省使用AspectJ切入点语法。 通俗讲 在连接点的基础上 增加上切入规则 选择出需要进行增强的连接点 这些基于切入规则选出来的连接点 就称之为切入点。 切面 切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式）或者基于@Aspect注解的方式来实现。 通知 通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了 “around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。 通俗讲： 在spring底层的代理拦截下切入点后，将切入点交给切面类，切面类中就要有处理这些切入点的方法，这些方法就称之为通知（也叫增强 增强方法）。针对于切入点执行的过程，通知还分为不同的类型，分别关注切入点在执行过程中的不同的时机。目标对象 目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象 通俗讲：就是真正希望被访问到的对象。spring底层的动态代理对他进行了代理，具体能不能真的访问到目标对象，或在目标对象真正执行之前和之后是否做一些额外的操作，取决于切面。案例1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"firstAspect\"&gt; &lt;!--配置通知方法--&gt; &lt;aop:before method=\"myBefore\" pointcut=\"within(cn.tedu.service.UserServiceImpl)\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 123456@Componentpublic class FirstAspect &#123; public void myBefore()&#123; System.out.println(\"记录日志\"); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringDay03","slug":"SpringDay03","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T09:19:58.546Z","comments":true,"path":"2020/01/29/SpringDay03/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay03/","excerpt":"","text":"Spring注解方式实现IOC和DI1.Spring注解Spring除了默认的使用xml配置&lt;bean&gt;标签的方式实现配置外，也可以通过注解的方式来实现配置，这种方式效率更高，配置信息清晰，代码在哪对应的配置也在哪儿。所谓注解就是程序看的提示信息，很多时候都用来作为轻量级配置方式 Spring注解方式实现IOCa. 导入开发jar包b. 编写配置文件，并导入context约束 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;&lt;/beans&gt; c. 开启包扫描 1&lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; d. 使用注解注册bean 在配置的包中的额类上使用@Component注解，这个类会自动被注册为bean，使用当前类的class为的class，默认情况下判断类名的第二字母，如果是大写，首字母不变作为id，如果第二个字母是小写，首字母就是小写，默认作为id，也可以自己指定id e. 可以使bean类实现BeanNameAware接口，并实现其中setBeanName 方法， spring容器会在初始化bean时，调用此方法告知当前bean的id。通过这个方式可以获取 bean的id信息。 1234567@Component(\"person\")//指定标签id不指定类名的首字母小写public class Person implements BeanNameAware &#123; @Override public void setBeanName(String name) &#123; System.out.println(\"===\"+this.getClass().getName()+\"===\"+name); &#125;&#125; f. 注解方式实现工厂注册bean 1234567@Componentpublic class DogFactory &#123; @Bean//可以自己指定id，也可以默认getInstance public Dog getInstance()&#123; return new Dog(\"小黑\"); &#125;&#125; Spring注解方式实现DI123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd\"&gt; &lt;context:component-scan base-package=\"cn.tedu.domain\"&gt;&lt;/context:component-scan&gt; &lt;!--开启注解方式的DI--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:property-placeholder location=\"my.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;util:list id=\"list\"&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/util:list&gt; &lt;util:set id=\"set\"&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;value&gt;333&lt;/value&gt; &lt;/util:set&gt; &lt;util:map id=\"map\"&gt; &lt;entry key=\"k1\" value=\"v1\"&gt;&lt;/entry&gt; &lt;/util:map&gt; &lt;util:properties id=\"properties\"&gt; &lt;prop key=\"1\"&gt;小&lt;/prop&gt; &lt;/util:properties&gt;&lt;/beans&gt; 在类的属性中通过@Value注入赋值1234567891011121314151617181920212223242526272829@Componentpublic class Hero &#123; //@Value(\"亚索\") @Value(\"$&#123;name&#125;\") private String name; //@Value(\"13\") @Value(\"$&#123;age&#125;\") private int age; @Value(\"#&#123;@list&#125;\") private List&lt;String&gt; list; @Value(\"#&#123;@set&#125;\") private Set&lt;String&gt; set; @Value(\"#&#123;@map&#125;\") private Map&lt;String,String&gt; map; @Value(\"#&#123;@properties&#125;\") private Properties props; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", list=\" + list + \", set=\" + set + \", map=\" + map + \", props=\" + props + '&#125;'; &#125;&#125; f.使用注解注入自定义bean类型数据在bean中的属性上通过@Autowired实现自定义bean类型的属性注入代码1234567891011121314151617181920@Componentpublic class Hero &#123; @Value(\"亚索\") private String name; @Value(\"10\") private int age; @Autowired @Qualifier(\"JMDog\")//一旦配置了@Qualifier(\"JMDog\")会按照指定id注入，找到注入，找不到就抛出异常 //@Resource(name = \"JMDog\") Java提供的不是Spring提供的，基本不用 private Dog dog; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", dog=\" + dog + '&#125;'; &#125;&#125; 当Spring容器解析到@Component注解时，创建当前类的bean在Spring容器中进行管理，在创建bean的过程中发现了@Autowired注解，会根据当前bean的类型，寻找Spring中是否存在该类型的bean，如果唯一的bean，直接注入，如果有多个根据id判断，如果有注入，如果没有抛出异常 其次，可以额外配置@Qualifier（“”）注解强制要求按照id进行寻找，找到就注入，找不到就抛出异常，注意@Autowired&@Qualifier（“”）需要配合使用 其他注解 @Scope(value=”prototype”) 配置修饰类是单例还是多例，Spring默认是单例12345//配置bean为多例@Component@Scope(\"prototype\")public class Person &#123;&#125; @Lazy 配置修饰的类的bean采用懒加载机制 Spring默认在初始化时就通过反射创建对象，并且以键值对的形式存入Spring容器中的Map集合中，在类上配置懒加载的注释，可以在对象使用时再创建，避免内存的浪费1234567@Component@Lazy//懒加载public class Person2 &#123; public Person2() &#123; System.out.println(\"person2...init\"); &#125;&#125; @PostConstruct 在bean对应的类中 修饰某个方法 将该方法声明为初始化方法，对象创建之后立即执 行。1234@PostConstruct public void initConn()&#123; System.out.println(\"初始化数据库连接\"); &#125; @PreDestroy 在bean对应的类中 修饰某个方法 将该方法声明为销毁的方法，对象销毁之前调用的方 法。1234@PreDestroy public void destroyConn()&#123; System.out.println(\"销毁数据库连接\"); &#125; @Controller @Service @Repository @Component 这四个注解的功能是完全相同的，都是用来修饰类，将雷声名为Spring管理的bean的 @Component 一般认为是通用的注解 @Controller 用在软件分层的控制层，一般用在web层上 @Service用在业务访问层，service层 @Repository用在数据访问层（Dao层） 利用Spring IOC DI 实现软件分层解耦 软件分层思想回顾 在软件领域有MVC软件设计思想，指导着软件开发过程。在javaee开发领域，javaee 的经典三层架构MVC设计思想的经典应用。而在软件设计思想中，追求的是”高内聚 低 耦合”的目标，利用Spring的IOC 和 DI 可以非常方便的实现这个需求。 12345678910111213141516171819202122232425262728293031323334353637383940//创建不同类的数据的类型实现userDao接口@Repository(\"userDao\")public class OracleUserDao implements UserDao&#123; @Override public void addUser() &#123; System.out.println(this+\"正在向数据库添加用户\"); &#125;&#125;@Repositorypublic class MySqlUserDao implements UserDao &#123; @Override public void addUser() &#123; System.out.println(this+\"正在添加用户\"); &#125;&#125;public interface UserDao &#123; public void addUser();&#125;//service层@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserDao userDao = null; @Override public void regist() &#123; userDao.addUser(); &#125;&#125;public interface UserService &#123; public void regist();&#125;//web层@Controllerpublic class RegistServlet &#123; @Autowired private UserService service = null; public void regist() &#123; service.regist(); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringDay06","slug":"SpringDay06","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-14T14:50:47.212Z","comments":true,"path":"2020/01/29/SpringDay06/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay06/","excerpt":"","text":"1.通过aop进行权限的控制 通过自定义注解声明业务方法是否需要权限控制 通过权限注解上的属性声明需要什么样的权限 通过切面拦截业务的方法，根据是否需要权限，是否具有权限，控制目标方法的执行关键代码123456789101112131415161718192021222324252627//切面代码@Component@Aspectpublic class PrivAspect &#123; @Around(\"execution(* cn.tedu.servive..*(..))\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; //1.获取目标对象 Object target = pjp.getTarget(); //2.获取目标方法 MethodSignature signature = (MethodSignature) pjp.getSignature(); Method method = signature.getMethod();//接口上的方法 //3.获取实现类上的目标方法 Method methodInstance = target.getClass().getMethod(method.getName(), method.getParameterTypes()); //4.判断是否有注解 if (methodInstance.isAnnotationPresent(PrivAnno.class))&#123; PrivAnno annotation = methodInstance.getAnnotation(PrivAnno.class); PrivEnum[] privEnums = annotation.value(); if (Arrays.asList(privEnums).contains(Test01.priv)) &#123; return pjp.proceed(); &#125;else &#123; throw new RuntimeException(\"权限不够\"); &#125; &#125;else &#123; return pjp.proceed(); &#125; &#125;&#125; 1234//枚举类public enum PrivEnum &#123; ADMIN,SUPERADMIN,VISITOR&#125; 123456//开发注释，来进行权限控制@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface PrivAnno &#123; PrivEnum [] value() ;&#125; 实现事务的控制 通过AOP实现事务的控制 开发事务注解，通过业务方法上是否有注解来表示方法是否需要事务 在切面中判断目标方法是否具有事务注解决定是否执行事务 通过事务管理器管理事务防止耦合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//jdbc连接工具类public class JDBCUtils &#123; private JDBCUtils() &#123; &#125; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public static Connection getConn() &#123; try &#123; return DriverManager.getConnection(\"jdbc:mysql:///mydb2\",\"root\",\"root1234\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public static void release(Connection conn, Statement stat, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; rs = null; &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; stat = null; &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; conn = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//事务管理public class TransactionManager &#123; private static Connection conn = JDBCUtils.getConn(); private TransactionManager()&#123; &#125; /** * 开启事务 */ public static void startTran()&#123; try &#123; conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /** * 获取连接 */ public static Connection getConn()&#123; return conn; &#125; /** * 提交事务 */ public static void commitTran()&#123; try &#123; conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /** * 回滚事务 */ public static void rollbackTran()&#123; try &#123; conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /** * 释放资源 */ public static void release()&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; 12345678910111213141516171819//切面类@Component@Aspectpublic class TransAspect &#123; @Around(\"execution(* cn.tedu.service..*(..)) &amp;&amp; @annotation(ax)\") public Object myAround(ProceedingJoinPoint pjp, Trans ax) throws Throwable &#123; try &#123; TransactionManager.startTran(); Object retObj = pjp.proceed(); TransactionManager.commitTran(); return retObj; &#125; catch (Throwable e) &#123; TransactionManager.rollbackTran(); throw e; &#125; finally &#123; TransactionManager.release(); &#125; &#125; spring整合JDBC-声名式事务处理1234567&lt;!--配置数据源--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///mydb2\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root1234\"&gt;&lt;/property&gt; &lt;/bean&gt; 12345678910&lt;!--配置jdbc模版--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///mydb2\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root1234\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; Spring中的事务管理（配置文件）123456789101112131415161718&lt;!--配置事务管理--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pc01\" expression=\"execution(* cn.tedu.service..* (..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pc01\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\" &gt; &lt;tx:attributes&gt; &lt;!--rollback-for=\"java.lang.Throwable 对异常强制回滚，进行事务管理--&gt; &lt;tx:method name=\"addUser\" propagation=\"REQUIRED\" rollback-for=\"java.lang.Throwable\"/&gt; &lt;tx:method name=\"delUser\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; Spring中的事务管理（注解方式）12345678910111213141516171819&lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///mydb2\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root1234\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置jdbc模版类--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启注解方式事务管理--&gt; &lt;tx:annotation-driven/&gt; 指定开启事务的方法12345678@Transactional(rollbackFor = IOException.class) @Override public void addUser(User user) throws IOException &#123; userDao.addUser(user); //int i = 1/0; throw new IOException(\"io 异常\"); &#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringMVCDay01","slug":"SpringMVCDay01","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-21T11:17:33.901Z","comments":true,"path":"2020/01/29/SpringMVCDay01/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringMVCDay01/","excerpt":"","text":"1.SpringMVC概述SpringMVC是一个WEB层，控制层框架，主要用来负责与客户端交互，业务逻辑的调用。SpringMVC是Spring家族的一大组件，Spring整合SpringMVC可以做到无缝集成，特点：简单易用性能佳2.SpringMVC相对与Servlet的优势a. Servlet的开发配置相对麻烦，servlet特别多的时候web.xml文件将会非常的臃肿b. 每个Servlet都只能处理一个功能，如果需要多个功能就需要开发多个servlet，项目中存在大量的servlet显得臃肿。c. 获取请求参数进行类型转换封装数据到bean的过程比较繁琐。d. 其他开发中不方便的地方，例如乱码问题，数据格式处理，表单检索 spring MVC详解 SpringMVC的组件a. 前端控制器（DispatcherServlet） 本质上是一个servlet，相当于一个中转站，所有的访问都会走到这个servlet中，再根据配置进行中转到相对应的handler中进行处理，获取数据和视图b. 处理器映射器（HandlerMapping） 本质上就是一段映射关系，将将访问路径和对应的Handler存储为映射关系，在需要时供前端控制器查阅。c. 处理器适配器（HandlerAdapter） 本质上就是一个适配器，可以根据要求找到对应的handler来运行。前端控制器找到处理器映射器找到对应的handler信息之后，将请求响应和对应的handler信息交由处理器适配器来处理，处理器适配器找到真正的handler执行后，将结果也就是model and view返回给前端控制器。d. 视图解析器（ViewResolver） 本质上是一种映射关系，可以将视图名称映射到真正的视图地址。前端控制器调用处理器适配完成后的到model和view，将view信息传给视图解析器得到真正的view。e. 视图（view） 本质上就是将handler处理器中返回的model数据嵌入到视图解析后得到的jsp页面中，向客户端作出响应 图解：&lt;&gt; 配置前端控制器1.前端控制器本身就是一个servlet ，首先要在WEB-INF下的web.xml中配置该web项目的servlet123456789101112131415&lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--手动配置核心文件的位置--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--配置servlet的映射--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 生成SpringMVC核心配置文件1234567&lt;!--配置处理器映射器中的路径和处理器的映射关系--&gt; &lt;bean name=\"/hello.action\" class=\"cn.tedu.web.Hello\"&gt;&lt;/bean&gt; &lt;!--配置视图解析器中视图名称和真正页面的映射关系，拼接上前缀后缀--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 123456789101112131415//创建类实现controller接口public class Hello implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //创建modelAndView ModelAndView modelAndView = new ModelAndView(); //封装数据 modelAndView.addObject(\"msg1\",\"hello world\"); modelAndView.addObject(\"msg2\",\"hello springMVC\"); //封装视图 modelAndView.setViewName(\"hello\"); //返回modelAndView return modelAndView; &#125;&#125; SpringMVC注解方式配置SpringMVC支持使用注解方式配置，比配置文件更加的灵活易用，是目前的主流配置方式springMVC注解工作原理 当服务器启动时，会先加载web.xml文件，之后通过引入核心配置文件来加载SpringMVC.xml 当解析到包扫描时，扫描指定的包，并将含有@Conteoller注解的类解析为处理器 如果配置过mvc:annotation-driven就会解析Spring-MVC注解 解析@requestMapping（value=“/test01.action”），将指定的地址和当前方法的映射关系保存 当客户端发出请求访问时，SpringMVC寻找改地址的映射关系，找到就执行方法，找不到抛出404 123456789&lt;!--配置包扫描--&gt;&lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt;&lt;!--配置mvc注解方式的DI--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--配置视图解析器中视图名称和真正页面的映射关系--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 1234567891011121314&lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--手动配置核心文件的位置--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; test01.jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;this is test01.jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;$&#123;msg&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718//测试//在类上加上注解指的是在访问的地址上加上前缀@RequestMapping(\"/my01\")@Controllerpublic class Controller01 &#123; @RequestMapping(\"/test01.action\") public String test01(Model model)&#123; model.addAttribute(\"msg\",\"one word one dream\"); return \"test01\"; &#125; //通过value属性指定当前的映射到那些路径,可以映射到多个路径 @RequestMapping(&#123;\"/test04.action\",\"/test02.action\",\"/test03.action\"&#125;) public String test02(Model model)&#123; System.out.println(\"just do it\"); model.addAttribute(\"msg\",\"one word one dream\"); return \"test02\"; &#125;&#125; SpringMVC获取请求参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@Controllerpublic class MyController01 &#123; /** * 获取请求参数：日期数据处理 * 通过注册自定义类型编辑器使SpringMVC支持自定义格式请求参数的处理 * 此处，SpringMVC为Date类型已经提供了编辑器类，所以直接使用，不用自己写 * http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01test09.jsp */ @InitBinder public void myInitBinder(ServletRequestDataBinder dataBinder)&#123; dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat(\"yyyy-MM-dd\"),true)); &#125; @RequestMapping(\"/test09.action\") public void test09(String name, int age, Date birthday) &#123; System.out.println(name); System.out.println(age); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); String format1 = format.format(birthday); System.out.println(format1); &#125; /** * 获取请求参数：中文乱码解决 * 如果服务器配置的编码是utf-8,且项目采用的也是utf-8则默认请求参数无乱码 * tomcat8默认编码为utf-8(可以更改) * tomcat7及更老的版本默认编码为iso8859-1(可以更改) * 如果遇到服务器编码和项目编码不一致时会产生乱码 * 对于POST提交 可以通过request.setCharacterEncoding(\"utf-8\")解决乱码 * 但此行代码对GET无效，GET提交的请求参数乱码，只能手工编解码来解决 * 手工编解码解决乱码的方式对POST提交也有效 * springmvc提供了过滤器CharacterEncodingFilter来帮助我们解决乱码 * 但此过滤器本质上就是request.setCharacterEncoing()所以也是只对POST有效 * ,即使配置了GET提交乱码也要手动解决 * */ @RequestMapping(\"/test08.action\") public void test08(HttpServletRequest request) throws UnsupportedEncodingException &#123; //POST提交 //request.setCharacterEncoding(\"utf-8\"); //String uname = request.getParameter(\"uname\"); //System.out.println(uname); //GET提交 //String uname = request.getParameter(\"uname\"); //byte [] data = uname.getBytes(\"iso8859-1\"); //uname = new String(data,\"utf-8\"); //System.out.println(uname); &#125; // 获取请求参数：多个同名请求参数的处理 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test07.action?name=tt&amp;love=bb&amp;love=pp&amp;love=zz @RequestMapping(\"/test07.action\") public void test07(String name,String [] love) &#123; //封装到数组里 System.out.println(name); System.out.println(Arrays.asList(love)); &#125; //获取请求参数：自动封装请求参数到bean 对复杂类型的处理 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test06.action?id=35&amp;name=jj&amp;age=18&amp;addr=cd&amp;dog.name=wd&amp;dog.age=1&amp;dog.cat.name=xx&amp;dog.cat.age=3 @RequestMapping(\"/test06.action\") public void test06(User user) &#123; System.out.println(user); &#125; //获取请求参数：自动封装请求参数到bean 对复杂类型的处理 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test05.action?id=35&amp;name=jj&amp;age=18&amp;addr=cd&amp;dog.name=wd&amp;dog.age=1 @RequestMapping(\"/test05.action\") public void test05(User user) &#123; System.out.println(user); &#125; //获取请求参数：自动封装请求参数到bean // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test04.action?id=35&amp;name=jj&amp;age=18&amp;addr=cd @RequestMapping(\"/test04.action\") public void test04(User user) &#123; System.out.println(user); &#125; //获取请求参数: 通过@RequestParam指定参数赋值,解决请求参数名和方法参数不一致时赋值问题 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test03.action?name=yasuo&amp;uage=19 @RequestMapping(\"/test03.action\") public void test03(@RequestParam(\"name\") String username, @RequestParam(\"uage\") int age) &#123; System.out.println(username + \"~~~~\" + age); &#125; //获取请求参数: 直接获取 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test02.action?username=yasuo&amp;age=19 @RequestMapping(\"/test02.action\") public void test02(String username, int age) &#123; System.out.println(username + \"~~~~\" + age); &#125; //获取请求参数：传统方式获取 // http://localhost:8080/SpringMVCDay01_04_Params_war_exploded/my01/test01.action?username=yasuo&amp;age=19 @RequestMapping(\"/test01.action\") public void test01(HttpServletRequest request) &#123; String username = request.getParameter(\"username\"); int age = Integer.parseInt(request.getParameter(\"age\")); System.out.println(username + \"~~~~\" + age); &#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"redis-cluster","slug":"redis-cluster","date":"2020-01-29T04:22:20.000Z","updated":"2020-03-18T06:23:14.782Z","comments":true,"path":"2020/01/29/redis-cluster/","link":"","permalink":"http://yoursite.com/2020/01/29/redis-cluster/","excerpt":"","text":"特点： 两两互联，任意节点和其他节点通信，底层使用二进制协议优化传输速度 引入新的数据分片计算方法（hash槽）引入hash取模（散列算法CRC16后对16384取余槽道","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringDay02","slug":"SpringDay02","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T09:19:23.414Z","comments":true,"path":"2020/01/29/SpringDay02/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay02/","excerpt":"","text":"单例和多例Spring容器管理的bean在默认情况下是单例，也就是一个bean创建一个对象，存在内置Map集合中，之后无论获取多少次该bean，都返回的同一个对象。bean在单例模式的生命周期：bean在单例模式下，Spring容器启动时解析xml发现该bean标签后，直接创建该bean的对象存入内部map中保存，此后无论调用多少次getBean（）都是从map中获取该对象返回，一直是一个对象，次对象一直被Spring容器持有，知道容器退出时，随着容器的退出对象被销毁案例-单例123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置约束条件可以设置从bean中获取对象是单例还是多例 scope=\"prototype\"是多例 scope=\"singleton\"是单例 Spring容器默认配置是单例 所以不配置是单例 --&gt; &lt;bean id=\"person\" class=\"cn.tedu.domain.Person\" scope=\"singelton\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345678910111213//测试单例 @Test public void test01()&#123; //初始化Spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //获取bean对象 Person person1 = (Person) context.getBean(\"person\"); Person person2 = (Person) context.getBean(\"person\"); System.out.println(person1);//cn.tedu.domain.Person@2df3b89c System.out.println(person2);//cn.tedu.domain.Person@2df3b89c //关闭容器 ((ClassPathXmlApplicationContext) context).close(); &#125; bean在多例模式下的生命周期：bean在多例模式下，Spring容器启动时解析xml时发现bean标签后，只是将该bean进行管理，并不会创建对象，此后每次使用getBean（）获取该bean时，Spring都会重新创建该对象返回，每次都是一个新的对象。这个对象Spring容器不会持有，什么时候销毁取绝于使用对象自己销毁。案例-多例1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置约束条件可以设置从bean中获取对象是单例还是多例 scope=\"prototype\"是多例 scope=\"singleton\"是单例 Spring容器默认配置是单例 所以不配置是单例 --&gt; &lt;bean id=\"person\" class=\"cn.tedu.domain.Person\" scope=\"prototype\"&gt;&lt;/bean&gt; 懒加载机制Spring默认在容器初始化的过程中，解析xml，并且创建单例的bean保存到map中，这样的机制在bean较少时问题不大，但一旦bean非常多时，Spring需要在启动的过程中花费大量的时间来创建bean花费大量的空间来存储bean，但这些bean可能很就都用不上，这种在启动时在时间和空间上的浪费很不值得。所以spring提供了懒加载机制。所谓的懒加载机制就是可以规定指定的bean不在启动时立刻创建，而是后续在第一次使用到才创建，从而减轻在启动过程中对时间和内存的消耗 懒加载机制只对单例bean有作用，对于多例bean设置懒加载没有意义 懒加载只是延后了对象的创建的时机，对象仍然是单例 懒加载的配置方式为指定bean配置懒加载1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" &gt;&lt;!--设置指定bean的懒加载default-lazy-init=\"true\"--&gt;&lt;bean id=\"person\" class=\"cn.tedu.domain.Person\" lazy-init=\"true\"&gt;&lt;/bean&gt;&lt;/beans&gt; 为全局配置懒加载1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-lazy-init=\"true\"&gt;&lt;!--设置默认全局配置的懒加载default-lazy-init=\"true\"--&gt;&lt;bean id=\"person\" class=\"cn.tedu.domain.Person\"&gt;&lt;/bean&gt;&lt;/beans&gt; 配置初始化和销毁的方法在Spring中如果某个bean在初始化之后or销毁之前要做一些额外操作可以为该bean配置厨师化和销毁的方法，在这些方法中完成功能Spring约束文件1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置初始化和摧毁的方法--&gt;&lt;bean id=\"jdbcUtils\" class=\"cn.tedu.domain.JDBCUtils\" init-method=\"myInit\" destroy-method=\"myDestroy\"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring中关键方法的执行顺序：!!!! 在Spring创建bean对象时，先创建对象（通过无参构造or工厂），之后立即调用init方式来执行初始化操作，之后此bean就可以哪来调用其它普通方法，而在对象销毁之前，Spring容器调用其destroy方法来执行销毁操作 Spring DIIOC（DI）-控制反转（依赖注入）所谓的IOC称之为控制反转，简单来说就是将对象的创建的权利及对象的生命周期的管理过程交由Spring框架来处理，从此在开发过程中不再需要关注对象的创建和生命周期的管理，而是在需要时由Spring框架提供，这个由Spring框架管理对象创建和生命周期的机制称之为控制反转。 而在创建对象的过程中Spring可以配置对对象的属性进行设置，这个过程称之为依赖注入也即DIset方法注入通常的javabean属性都会私有化，而对外暴露setXxx（）getXxx方法，此时Spring可以通过这样的setXxx（）方法将属性的值注入对象123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\"&gt; &lt;property name=\"name\" value=\"亚索\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"job\"&gt; &lt;list&gt; &lt;value&gt;程序员&lt;/value&gt; &lt;value&gt;架构师&lt;/value&gt; &lt;value&gt;大数据工程师&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;10000&lt;/value&gt; &lt;value&gt;40000&lt;/value&gt; &lt;value&gt;30000&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"亚索\" value=\"德玛西亚\"&gt;&lt;/entry&gt; &lt;entry key=\"刀妹\" value=\"艾欧尼亚\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"props\"&gt; &lt;props&gt; &lt;prop key=\"1\"&gt;亚索&lt;/prop&gt; &lt;prop key=\"2\"&gt;刀妹&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义bean的注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\"&gt; &lt;property name=\"name\" value=\"亚索\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"job\"&gt; &lt;list&gt; &lt;value&gt;程序员&lt;/value&gt; &lt;value&gt;架构师&lt;/value&gt; &lt;value&gt;大数据工程师&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;10000&lt;/value&gt; &lt;value&gt;40000&lt;/value&gt; &lt;value&gt;30000&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"亚索\" value=\"德玛西亚\"&gt;&lt;/entry&gt; &lt;entry key=\"刀妹\" value=\"艾欧尼亚\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"props\"&gt; &lt;props&gt; &lt;prop key=\"1\"&gt;亚索&lt;/prop&gt; &lt;prop key=\"2\"&gt;刀妹&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"dog\" ref=\"dog\" &gt;&lt;/property&gt; &lt;property name=\"cat\" ref=\"cat\"&gt;&lt;/property&gt; &lt;property name=\"snake\" ref=\"snake\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dog\" class=\"cn.tedu.domain.Dog\" &gt; &lt;property name=\"name\" value=\"jobs\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"11\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"cat\" class=\"cn.tedu.domain.Cat\"&gt; &lt;property name=\"name\" value=\"tom\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"4\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"snake\" class=\"cn.tedu.domain.Snake\"&gt; &lt;property name=\"name\" value=\"小白\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"1000\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 自动装配在Spring的set方式实现注入的过程中，支持自动装配机制，所谓的自动装配机制，会根据要设置的javabean属性的名字or类型到Spring中自动寻找对应的idor类型的进行设置，从而省去依次配置的过程，简化了配置123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- autowire=\"byName\" 根据javabean中需要注入属性的名字，在Spring容器中找到对应类型的id进行自动装配 autowire=\"byType\" 根据javabean中需要注入属性的类型，在Spring容器中找到对应的class类型进行配置 --&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\" autowire=\"byName\"&gt; &lt;/bean&gt; &lt;bean id=\"dog\" class=\"cn.tedu.domain.Dog\" &gt; &lt;property name=\"name\" value=\"jobs\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"11\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"cat\" class=\"cn.tedu.domain.Cat\"&gt; &lt;property name=\"name\" value=\"tom\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"4\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"snake\" class=\"cn.tedu.domain.Snake\"&gt; &lt;property name=\"name\" value=\"小白\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"1000\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 基于构造方法的注入对象属性设置的另一种方式是在对象创建的过程中通过构造方法传入参数并且设置对象的属性。123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\"&gt; &lt;constructor-arg index=\"0\" value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" value=\"旺财\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"2\" ref=\"dog\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"dog\" class=\"cn.tedu.domain.Dog\"&gt; &lt;property name=\"name\" value=\"小白\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"4\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"SpringDay05","slug":"SpringDay05","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-12T14:55:17.430Z","comments":true,"path":"2020/01/29/SpringDay05/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay05/","excerpt":"","text":"切入点表达式within表达式通过类名进行匹配，是一种粗粒度的切入点表达式，不可以指定某个方法进行增强，以类作为基本的单位在Spring的约束文件中配置切入点和切面（within切入点表达式）1234567891011121314151617 &lt;!--添加Spring AOP相关的约束 xmlns:aop=\"http://www.springframework.org/schema/aop\" http://www.springframework.org/schema/aop/spring-aop.xsd --&gt; &lt;!--配置包扫描--&gt; &lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; &lt;!--注释配置--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置切面类--&gt; &lt;aop:aspect ref=\"firstAspect\"&gt; &lt;!--指定切入点规则,通知方法--&gt; &lt;aop:before method=\"before\" pointcut=\"within(cn.tedu.service.UserServiceImpl)\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; execution表达式通过方法进行匹配，是一种细粒度的切入点表达式，以方法作为基本的单元123456&lt;aop:config&gt; &lt;aop:pointcut id=\"pc01\" expression=\"execution(* cn.tedu.service..*(..))\"/&gt; &lt;aop:aspect ref=\"firstAspect\"&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pc01\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring的五大通知类型前置通知 在目标方法执行之前执行的通知环绕通知 在目标方法执行之前，执行之后都会执行的通知后置通知 在目标方法执行之后的通知异常通知 在目标方法抛出异常后执行的通知最终通知 无论如何都会在目标方法调用后执行 多个通知执行顺序未出现异常前置通知 环绕通知前 目标方法（添加用户cn.tedu.domain.User@710f4dc7） 最终通知 环绕通知后 后置通知出现异常（）前置通知 环绕通知前 目标方法（添加用户cn.tedu.domain.User@710f4dc7） 最终通知 异常通知出现多个切面类时，采用了责任链设计模式，切面的配置顺序决定了通知的执行顺序。以两个切面为例：具体执行过程如下：web层调用service层目标方法时，会经过第一个切面，执行前置通知和环绕前通知，环绕通知调用proceed（）时进入下一个切面，执行第二个切面的前置通知，和环绕前通知，进入第二个切面的proceed的方法，放行调用目标方法，下面进入第二个切面的环绕后通知，和后置通知，最终通知，在进入第一个切面层，环绕后通知，和后置通知，最终通知，响应给web层代码执行结果1234567891011前置通知环绕通知前second前置通知second环绕通知前添加用户cn.tedu.domain.User@2de23121second最终通知second环绕通知后second后置通知最终通知环绕通知后后置通知","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-01-28T08:37:29.000Z","updated":"2020-02-01T11:53:20.471Z","comments":true,"path":"2020/01/28/单例模式/","link":"","permalink":"http://yoursite.com/2020/01/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式（饿汉式静态变量）1234567891011121314151617181920212223242526public class SingleTest1 &#123; @Test public void test()&#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance==instance1);//true &#125;&#125;//饿汉式（静态变量）//优点：这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题//缺点：没有实现lazy loading的效果，实例创建可能不会被使用，导致内存的浪费class Singleton&#123; //私有化构造方法，目的：不让外界随便创建实例 private Singleton()&#123; &#125; //本类部自己创建实例 private static Singleton instance = new Singleton(); //对外界提供公共的静态方法，返回实例的对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 饿汉式（静态代码块）1234567891011121314151617181920212223242526272829303132333435public class SingleTest2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton2 instance = Singleton2.getInstance(); Singleton2 instance1 = Singleton2.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//饿汉式（静态代码块）//优点：这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题//缺点：没有实现lazy loading的效果，实例创建可能不会被使用，导致内存的浪费class Singleton2 &#123; //私有化构造方法，目的：不让外界随便创建实例 private Singleton2() &#123; &#125; //在本类中声明实例 private static Singleton2 instance; static &#123; //在静态代码块中实例化对象 instance = new Singleton2(); &#125; //对外界提供公共的静态方法，返回实例的对象 public static Singleton2 getInstance() &#123; return instance; &#125;&#125; 单例设计模式（懒汉式线程不安全）123456789101112131415161718192021222324252627public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//懒汉式（多线程不安全）class Singleton &#123; private static Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 123456789101112131415161718192021222324252627282930public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//懒汉式（线程安全）//优点：解决了线程安全的问题//缺点：效率太低,不推荐使用class Singleton &#123; private static Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象,提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检查解决了多线程安全问题12345678910111213141516171819202122232425262728293031323334353637public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;// 双重检查 class Singleton &#123;//volatile防止指令重排推荐使用 private static volatile Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象 public static synchronized Singleton getInstance() &#123; //第一次检查 if (instance == null) &#123; synchronized (Singleton.class) &#123; //第二次检查 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类利用jvm的装载机制，当类加载时静态内部类不会立即被加载，保证了线程安全以及效率的问题1234567891011121314151617181920212223242526272829303132public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//静态内部类class Singleton &#123; private static volatile Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; private static class SingleInstance &#123; private static final Singleton instance = new Singleton(); &#125; //需要时再创建对象,提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() &#123; return SingleInstance.instance; &#125;&#125; 枚举使用枚举，可以实现单例，推荐使用，还能防止反序列化创建对象123456789101112131415161718public class SingletonTest8 &#123; public static void main(String[] args) &#123; Singleton instance = Singleton.INSTANCE; Singleton instance1 = Singleton.INSTANCE; System.out.println(instance == instance1);//true System.out.println(instance.hashCode()); System.out.println(instance1.hashCode()); &#125;&#125;enum Singleton &#123; INSTANCE;//属性 public void sayOk() &#123; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"My-first-blog","slug":"My-first-blog","date":"2020-01-28T04:21:00.000Z","updated":"2020-01-28T04:37:19.618Z","comments":true,"path":"2020/01/28/My-first-blog/","link":"","permalink":"http://yoursite.com/2020/01/28/My-first-blog/","excerpt":"","text":"Mac下 hexo博客的搭建安装Node.js这里可以去Nodejs的官网去下载安装 [hyperlink]（https://nodejs.org/en/） 点击downloads 选择合适的版本下载 打开电脑的终端切换到我们的sudo用户，这里是以管理员身份打开 执行代码：sudo su 显示Password：“输入密码” 查看node的版本，npm的版本 执行代码: node -v 执行代码: npm -v 安装hexo的框架这里使用npm包安装管理器来安装一个淘宝的cnpm的镜像源包安装管理器来安装 执行代码：npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后可以用代码cnpm 查看版本 用cnpm全局安装hexo博客 执行代码：cnpm install -g hexo-cli 安装完成后用hexo -v查看版本，确认安装完成。 查看当前路径:pwd 新建一个blog的文件夹 ：mkdir blog 注意！！！下面的所有操作都是在blog文件下操作，如果后面发生错误实在找不到删除blog文件夹重新操作即可。 进入blog文件夹，执行命令：cd blog hexo初始化 执行命令sudo hexo init 最后启动hexo blog 执行命令：hexo s 默认在http://localhost:4000/可以打开","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-27T03:52:03.728Z","updated":"2020-01-28T08:35:01.012Z","comments":true,"path":"2020/01/27/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]}]}