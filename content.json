{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Niklaus Yu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-01-28T03:13:25.000Z","updated":"2020-01-28T03:17:26.016Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-28T03:07:35.000Z","updated":"2020-01-28T03:10:00.598Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mybatis","slug":"mybatis框架","date":"2020-02-06T11:29:59.000Z","updated":"2020-02-06T13:32:12.026Z","comments":true,"path":"2020/02/06/mybatis框架/","link":"","permalink":"http://yoursite.com/2020/02/06/mybatis%E6%A1%86%E6%9E%B6/","excerpt":"","text":"mybatis的概述mybatis是一个持久层框架，用java编写的。 它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等复杂过程 它使用了ORM思想实现了结果集的封装ORM思想：Object Relational Mapping （对象关系映射）","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"工厂模式","slug":"工厂模式","date":"2020-02-01T12:30:09.000Z","updated":"2020-02-03T08:39:22.722Z","comments":true,"path":"2020/02/01/工厂模式/","link":"","permalink":"http://yoursite.com/2020/02/01/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式定义：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"Design Patterns","slug":"Design-Patterns","date":"2020-01-31T04:53:50.000Z","updated":"2020-02-01T10:13:04.969Z","comments":true,"path":"2020/01/31/Design-Patterns/","link":"","permalink":"http://yoursite.com/2020/01/31/Design-Patterns/","excerpt":"","text":"设计模式的类型设计模式分为三种类型，共23种 创建型模式：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。 结构型模式：适配器模式，装饰者模式，桥接模式，组合模式，外观模式，享元模式，代理模式 行为型模式：模版方法模式，命令模式，访问者模式，迭代器模式，观察者模式，备忘录模式，解释器模式（interpreter模式），状态模式，策略模式，职责链模式（责任链）模式。设计模式常用的七大原则1.单一职责原则 降低类的复杂度，一个类只负责一项职责 便于后期的代码的维护，提高代码的刻度性 降低后期因变更而引起的风险 通常情况下我们应该遵循单一职责原则，但在一个类中方法较少的时候，我们可以在方法的级别保持单一职责原则即可 2. 接口隔离原则 一个类通过接口依赖另一个类，该接口应该是最小接口，也就是通过接口的隔离保证类中不需要接口中多余的方法，如果接口中有用不到的方法，就把这个接口中拆分成多个小接口，避免造成浪费。 3. 依赖倒转原则（Dependence Inversion Principle）案例12345678910111213141516171819202122232425262728293031323334public class DependcyIversion &#123; public static void main(String[] args) &#123; Person person = new Person(); person.receive(new Email()); person.receive(new Weixin()); &#125;&#125;interface Ireceiver &#123; String getInfo();&#125;class Email implements Ireceiver &#123; @Override public String getInfo() &#123; return \"hello world\"; &#125;&#125;class Weixin implements Ireceiver &#123; @Override public String getInfo() &#123; return \"one world,one dream\"; &#125;&#125;class Person &#123; public void receive(Ireceiver ireceiver) &#123; System.out.println(ireceiver.getInfo()); &#125;&#125;//总结：通过类与接口发生依赖，与子实现类没有关系，这样便于后期的修改，这就是面向接口编程的思想 低层模块最好是抽象类或者接口，这样程序会更稳定 变量声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利用程序扩展和优化 继承时遵循里氏替换原则 4. 里氏替换原则 继承增加了程序的耦合性 子类尽量不要重写父类的方法，如果需要重写，就通过依赖，组合，聚合的方法，提升一个基类，让原有的父类和子类继承这个基类案例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(\"11-3=\" + a.fun1(11, 3)); System.out.println(\"1-8=\" + a.fun1(1, 8)); System.out.println(\"-----------\"); B b = new B(); System.out.println(\"11+3=\" + b.fun1(11, 3)); System.out.println(\"1+8=\" + b.fun1(1, 8)); System.out.println(\"11+3+9=\" + b.fun2(11, 3)); System.out.println(\"11-3=\" + b.fun3(11, 3)); &#125;&#125;class Base &#123;&#125;class A extends Base &#123; public int fun1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;//B类继承了A//增加了一个新功能：完成两个数相加，然后和9求和class B extends Base &#123; //通过依赖的方式与类A发生关系 private A a = new A(); public int fun1(int a, int b) &#123; return a + b; &#125; public int fun2(int a, int b) &#123; return fun1(a, b) + 9; &#125; public int fun3(int a, int b) &#123; return this.a.fun1(a, b); &#125;&#125; 5. 开闭原则 ocp(open closed principle) 是编程中最基础，最重要的设计原则6. 迪米特法则（最少知道原则） 降低类之间的耦合，对自己依赖的类知道的越少越好 降低类间（对象间）耦合关系，并不是要求完全没有依赖关系 直接朋友，出现在成员变量，方法参数，方法返回值，如果出现在局部变量中则是陌生朋友7. 合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo1 &#123; @Test public void test()&#123; Dog d = new Dog(); d.setAnimal(); &#125;&#125;class Animal &#123; void run()&#123; System.out.println(\"正在跑\"); &#125; void sleep()&#123; System.out.println(\"正在睡\"); &#125; void eat()&#123; System.out.println(\"正在吃\"); &#125;&#125;//方式一依赖/*class Dog &#123; public void action(Animal animal)&#123; animal.run(); animal.eat(); &#125;&#125;*///方式二聚合/*class Dog &#123; private Animal animal; public void setAnimal(Animal animal)&#123; animal.eat(); &#125;&#125;*///方式三：组合class Dog &#123; private Animal animal = new Animal(); public void setAnimal() &#123; animal.eat(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"SpringDay01","slug":"SpringDay01","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T09:18:51.390Z","comments":true,"path":"2020/01/29/SpringDay01/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay01/","excerpt":"","text":"框架（半成品软件）高度抽取可重用代码的一种设计，高度的通用性; 框架：抽取成一种高度可重用的；事务控制，强大的servlet，项目中的一些工具。 框架：多个可重用模块的集合，形成一个某个领域的整体解决方案；常见的框架SSH（老三大框架）Struts2 Spring HibernateSSM（新三大框架）SpringMVC(WEB) Spring（Service） Mybatis（Dao） Spring 框架Spring是一个service层的框架，可以整合其他框架 容器（可以管理所有的组件（类））框架；核心关注：IOC和AOPIOC：- 控制反转 AOP：- 面向切面编程案例一第一步:先导入jar包 第二步:配置Spring容器约束文件 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"person01\" class=\"cn.tedu.domain.Person01\"&gt;&lt;/bean&gt; &lt;bean id=\"person02\" class=\"cn.tedu.domain.Person01\"&gt;&lt;/bean&gt;&lt;/beans&gt; 案例一1234567891011121314151617181920212223242526272829303132333435363738394041/* spring 容器底层默认通过读取配置文件的类的全路径名，通过反射来创建对象* 并保存到Spring容器的Map内存中并且通过键值对的形式储存，降低了程序的耦合性* 通过getbean方法容器中找到匹配的键值对，来创建实例，多次获取同一个id的实例是同一个实例*/public class Test01 &#123; @Test public void test01()&#123; //初始化容器,ApplicationContext是接口创建实现类对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\"); //获取bean，获得对象 Person01 p = (Person01) context.getBean(\"person01\"); //调用p的方法 p.eat(); p.sleep(); System.out.println(p); //关闭容器 ((ClassPathXmlApplicationContext) context).close(); &#125; //如果配置文件中包含两个id则会抛出异常 BeanDefinitionParsingException, // 这是因为Spring容器在存储对象时默认以键值对的形式存储的不能出现相同的key值 @Test public void test02()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 p = (Person01) context.getBean(\"person01\"); System.out.println(p); &#125; /* * Spring容器中可以包含相同的class属性，对应不同的id,且获取的是不同的实例*/ @Test public void test03()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 p1 = (Person01) context.getBean(\"person01\"); Person01 p2 = (Person01) context.getBean(\"person02\"); System.out.println(p1);//cn.tedu.domain.Person01@6e0e048a System.out.println(p2);//cn.tedu.domain.Person01@5bc79255 //关闭资源 ((ClassPathXmlApplicationContext) context).close(); &#125;&#125; 案例二：创建bean的方式123456789101112131415161718192021222324252627282930313233//创建bean /* * Spring中默认是调用类的无参构造构造,通过反射来创建bean的 * 如果没有无参构造构造就不能直接配置类的全路径名获得bean*/ //Spring创建bean，没有无参构造构造，默认创建失败public class Test04 &#123; //java.lang.NoSuchMethodException:没有默认的无参构造 @Test public void test01()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 p = (Person01) context.getBean(\"person01\"); System.out.println(p); &#125; //通过反射创建对象 //java.lang.InstantiationException: cn.tedu.domain.Person01 //直接用clz.newstance,默认调用无参构造但只有含参数构造会抛出异常 // Caused by: java.lang.NoSuchMethodException: cn.tedu.domain.Person01.&lt;init&gt;() @Test public void test02() throws Exception &#123; Class&lt;?&gt; clz = Class.forName(\"cn.tedu.domain.Person01\"); Constructor&lt;?&gt; constructor = clz.getConstructor(String.class); Person01 p = (Person01) constructor.newInstance(\"reason\"); System.out.println(p);//cn.tedu.domain.Person01@1edf1c96 &#125; //普通方法创建对象 @Test public void test03()&#123; Person01 person01 = new Person01(\"xx\"); System.out.println(person01); &#125;&#125; 案例三：利用工厂获取bean1. 静态工厂1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置静态工厂--&gt; &lt;bean id=\"person01\" class=\"cn.tedu.factory.Person01StaticFactory\" factory-method=\"getInstance\"&gt;&lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718//创建静态工厂public class Person01StaticFactory &#123; //私有化构造方法，不让外界随意的创建对象 private Person01StaticFactory()&#123; &#125; //对外界提供公共的静态的getInstance的方法 public static Person01 getInstance()&#123; return new Person01(\"reason\"); &#125;&#125;//测试静态工厂 @Test public void test05()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person01 person01 = (Person01) context.getBean(\"person01\"); System.out.println(person01);//cn.tedu.domain.Person01@3b084709 &#125; 2. 实例工厂12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置实例工厂--&gt; &lt;bean id=\"person01InstanceFactory\" class=\"cn.tedu.factory.Person01InstanceFactory\" &gt;&lt;/bean&gt; &lt;bean id=\"person01\" factory-bean=\"person01InstanceFactory\" factory-method=\"getInstance\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345678910111213//创建实例工厂public class Person01InstanceFactory &#123; public Person01 getInstance()&#123; return new Person01(\"xx\"); &#125;&#125;//测试实例工厂@Test public void test06()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); Person01 person01 = (Person01) context.getBean(\"person01\"); System.out.println(person01);//cn.tedu.domain.Person01@3b084709 &#125; 3. Spring工厂1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!--配置Spring工厂--&gt; &lt;bean id=\"person01\" class=\"cn.tedu.factory.Person01SpringFactory\"&gt;&lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627//创建SpringFactory需要实现FactoryBean接口指定泛型为获取实例的泛型public class Person01SpringFactory implements FactoryBean&lt;Person01&gt; &#123; @Override public Person01 getObject() throws Exception &#123; //返回person01实例 return new Person01(\"xx\"); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; //返回实例的class对象 return Person01.class; &#125; @Override public boolean isSingleton() &#123; //是否是单例，Spring默认全局只有一个实例 return true; &#125;&#125;//测试Spring工厂 @Test public void test07()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext2.xml\"); Person01 person01 = (Person01) context.getBean(\"person01\"); System.out.println(person01);//cn.tedu.domain.Person01@23e028a9 &#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"SpringDay02","slug":"SpringDay02","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T09:19:23.414Z","comments":true,"path":"2020/01/29/SpringDay02/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay02/","excerpt":"","text":"单例和多例Spring容器管理的bean在默认情况下是单例，也就是一个bean创建一个对象，存在内置Map集合中，之后无论获取多少次该bean，都返回的同一个对象。bean在单例模式的生命周期：bean在单例模式下，Spring容器启动时解析xml发现该bean标签后，直接创建该bean的对象存入内部map中保存，此后无论调用多少次getBean（）都是从map中获取该对象返回，一直是一个对象，次对象一直被Spring容器持有，知道容器退出时，随着容器的退出对象被销毁案例-单例123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置约束条件可以设置从bean中获取对象是单例还是多例 scope=\"prototype\"是多例 scope=\"singleton\"是单例 Spring容器默认配置是单例 所以不配置是单例 --&gt; &lt;bean id=\"person\" class=\"cn.tedu.domain.Person\" scope=\"singelton\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345678910111213//测试单例 @Test public void test01()&#123; //初始化Spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //获取bean对象 Person person1 = (Person) context.getBean(\"person\"); Person person2 = (Person) context.getBean(\"person\"); System.out.println(person1);//cn.tedu.domain.Person@2df3b89c System.out.println(person2);//cn.tedu.domain.Person@2df3b89c //关闭容器 ((ClassPathXmlApplicationContext) context).close(); &#125; bean在多例模式下的生命周期：bean在多例模式下，Spring容器启动时解析xml时发现bean标签后，只是将该bean进行管理，并不会创建对象，此后每次使用getBean（）获取该bean时，Spring都会重新创建该对象返回，每次都是一个新的对象。这个对象Spring容器不会持有，什么时候销毁取绝于使用对象自己销毁。案例-多例1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置约束条件可以设置从bean中获取对象是单例还是多例 scope=\"prototype\"是多例 scope=\"singleton\"是单例 Spring容器默认配置是单例 所以不配置是单例 --&gt; &lt;bean id=\"person\" class=\"cn.tedu.domain.Person\" scope=\"prototype\"&gt;&lt;/bean&gt; 懒加载机制Spring默认在容器初始化的过程中，解析xml，并且创建单例的bean保存到map中，这样的机制在bean较少时问题不大，但一旦bean非常多时，Spring需要在启动的过程中花费大量的时间来创建bean花费大量的空间来存储bean，但这些bean可能很就都用不上，这种在启动时在时间和空间上的浪费很不值得。所以spring提供了懒加载机制。所谓的懒加载机制就是可以规定指定的bean不在启动时立刻创建，而是后续在第一次使用到才创建，从而减轻在启动过程中对时间和内存的消耗 懒加载机制只对单例bean有作用，对于多例bean设置懒加载没有意义 懒加载只是延后了对象的创建的时机，对象仍然是单例 懒加载的配置方式为指定bean配置懒加载1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" &gt;&lt;!--设置指定bean的懒加载default-lazy-init=\"true\"--&gt;&lt;bean id=\"person\" class=\"cn.tedu.domain.Person\" lazy-init=\"true\"&gt;&lt;/bean&gt;&lt;/beans&gt; 为全局配置懒加载1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-lazy-init=\"true\"&gt;&lt;!--设置默认全局配置的懒加载default-lazy-init=\"true\"--&gt;&lt;bean id=\"person\" class=\"cn.tedu.domain.Person\"&gt;&lt;/bean&gt;&lt;/beans&gt; 配置初始化和销毁的方法在Spring中如果某个bean在初始化之后or销毁之前要做一些额外操作可以为该bean配置厨师化和销毁的方法，在这些方法中完成功能Spring约束文件1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置初始化和摧毁的方法--&gt;&lt;bean id=\"jdbcUtils\" class=\"cn.tedu.domain.JDBCUtils\" init-method=\"myInit\" destroy-method=\"myDestroy\"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring中关键方法的执行顺序：!!!! 在Spring创建bean对象时，先创建对象（通过无参构造or工厂），之后立即调用init方式来执行初始化操作，之后此bean就可以哪来调用其它普通方法，而在对象销毁之前，Spring容器调用其destroy方法来执行销毁操作 Spring DIIOC（DI）-控制反转（依赖注入）所谓的IOC称之为控制反转，简单来说就是将对象的创建的权利及对象的生命周期的管理过程交由Spring框架来处理，从此在开发过程中不再需要关注对象的创建和生命周期的管理，而是在需要时由Spring框架提供，这个由Spring框架管理对象创建和生命周期的机制称之为控制反转。 而在创建对象的过程中Spring可以配置对对象的属性进行设置，这个过程称之为依赖注入也即DIset方法注入通常的javabean属性都会私有化，而对外暴露setXxx（）getXxx方法，此时Spring可以通过这样的setXxx（）方法将属性的值注入对象123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\"&gt; &lt;property name=\"name\" value=\"亚索\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"job\"&gt; &lt;list&gt; &lt;value&gt;程序员&lt;/value&gt; &lt;value&gt;架构师&lt;/value&gt; &lt;value&gt;大数据工程师&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;10000&lt;/value&gt; &lt;value&gt;40000&lt;/value&gt; &lt;value&gt;30000&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"亚索\" value=\"德玛西亚\"&gt;&lt;/entry&gt; &lt;entry key=\"刀妹\" value=\"艾欧尼亚\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"props\"&gt; &lt;props&gt; &lt;prop key=\"1\"&gt;亚索&lt;/prop&gt; &lt;prop key=\"2\"&gt;刀妹&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义bean的注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\"&gt; &lt;property name=\"name\" value=\"亚索\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"job\"&gt; &lt;list&gt; &lt;value&gt;程序员&lt;/value&gt; &lt;value&gt;架构师&lt;/value&gt; &lt;value&gt;大数据工程师&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;10000&lt;/value&gt; &lt;value&gt;40000&lt;/value&gt; &lt;value&gt;30000&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"亚索\" value=\"德玛西亚\"&gt;&lt;/entry&gt; &lt;entry key=\"刀妹\" value=\"艾欧尼亚\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"props\"&gt; &lt;props&gt; &lt;prop key=\"1\"&gt;亚索&lt;/prop&gt; &lt;prop key=\"2\"&gt;刀妹&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"dog\" ref=\"dog\" &gt;&lt;/property&gt; &lt;property name=\"cat\" ref=\"cat\"&gt;&lt;/property&gt; &lt;property name=\"snake\" ref=\"snake\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dog\" class=\"cn.tedu.domain.Dog\" &gt; &lt;property name=\"name\" value=\"jobs\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"11\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"cat\" class=\"cn.tedu.domain.Cat\"&gt; &lt;property name=\"name\" value=\"tom\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"4\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"snake\" class=\"cn.tedu.domain.Snake\"&gt; &lt;property name=\"name\" value=\"小白\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"1000\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 自动装配在Spring的set方式实现注入的过程中，支持自动装配机制，所谓的自动装配机制，会根据要设置的javabean属性的名字or类型到Spring中自动寻找对应的idor类型的进行设置，从而省去依次配置的过程，简化了配置123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- autowire=\"byName\" 根据javabean中需要注入属性的名字，在Spring容器中找到对应类型的id进行自动装配 autowire=\"byType\" 根据javabean中需要注入属性的类型，在Spring容器中找到对应的class类型进行配置 --&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\" autowire=\"byName\"&gt; &lt;/bean&gt; &lt;bean id=\"dog\" class=\"cn.tedu.domain.Dog\" &gt; &lt;property name=\"name\" value=\"jobs\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"11\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"cat\" class=\"cn.tedu.domain.Cat\"&gt; &lt;property name=\"name\" value=\"tom\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"4\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"snake\" class=\"cn.tedu.domain.Snake\"&gt; &lt;property name=\"name\" value=\"小白\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"1000\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 基于构造方法的注入对象属性设置的另一种方式是在对象创建的过程中通过构造方法传入参数并且设置对象的属性。123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hero\" class=\"cn.tedu.domain.Hero\"&gt; &lt;constructor-arg index=\"0\" value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" value=\"旺财\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"2\" ref=\"dog\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"dog\" class=\"cn.tedu.domain.Dog\"&gt; &lt;property name=\"name\" value=\"小白\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"4\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"SpringDay03","slug":"SpringDay03","date":"2020-01-29T04:22:20.000Z","updated":"2020-02-11T09:19:58.546Z","comments":true,"path":"2020/01/29/SpringDay03/","link":"","permalink":"http://yoursite.com/2020/01/29/SpringDay03/","excerpt":"","text":"Spring注解方式实现IOC和DI1.Spring注解Spring除了默认的使用xml配置&lt;bean&gt;标签的方式实现配置外，也可以通过注解的方式来实现配置，这种方式效率更高，配置信息清晰，代码在哪对应的配置也在哪儿。所谓注解就是程序看的提示信息，很多时候都用来作为轻量级配置方式 Spring注解方式实现IOCa. 导入开发jar包b. 编写配置文件，并导入context约束 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;&lt;/beans&gt; c. 开启包扫描 1&lt;context:component-scan base-package=\"cn.tedu\"&gt;&lt;/context:component-scan&gt; d. 使用注解注册bean 在配置的包中的额类上使用@Component注解，这个类会自动被注册为bean，使用当前类的class为的class，默认情况下判断类名的第二字母，如果是大写，首字母不变作为id，如果第二个字母是小写，首字母就是小写，默认作为id，也可以自己指定id e. 可以使bean类实现BeanNameAware接口，并实现其中setBeanName 方法， spring容器会在初始化bean时，调用此方法告知当前bean的id。通过这个方式可以获取 bean的id信息。 1234567@Component(\"person\")//指定标签id不指定类名的首字母小写public class Person implements BeanNameAware &#123; @Override public void setBeanName(String name) &#123; System.out.println(\"===\"+this.getClass().getName()+\"===\"+name); &#125;&#125; f. 注解方式实现工厂注册bean 1234567@Componentpublic class DogFactory &#123; @Bean//可以自己指定id，也可以默认getInstance public Dog getInstance()&#123; return new Dog(\"小黑\"); &#125;&#125; Spring注解方式实现DI123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd\"&gt; &lt;context:component-scan base-package=\"cn.tedu.domain\"&gt;&lt;/context:component-scan&gt; &lt;!--开启注解方式的DI--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:property-placeholder location=\"my.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;util:list id=\"list\"&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/util:list&gt; &lt;util:set id=\"set\"&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;value&gt;333&lt;/value&gt; &lt;/util:set&gt; &lt;util:map id=\"map\"&gt; &lt;entry key=\"k1\" value=\"v1\"&gt;&lt;/entry&gt; &lt;/util:map&gt; &lt;util:properties id=\"properties\"&gt; &lt;prop key=\"1\"&gt;小&lt;/prop&gt; &lt;/util:properties&gt;&lt;/beans&gt; 在类的属性中通过@Value注入赋值1234567891011121314151617181920212223242526272829@Componentpublic class Hero &#123; //@Value(\"亚索\") @Value(\"$&#123;name&#125;\") private String name; //@Value(\"13\") @Value(\"$&#123;age&#125;\") private int age; @Value(\"#&#123;@list&#125;\") private List&lt;String&gt; list; @Value(\"#&#123;@set&#125;\") private Set&lt;String&gt; set; @Value(\"#&#123;@map&#125;\") private Map&lt;String,String&gt; map; @Value(\"#&#123;@properties&#125;\") private Properties props; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", list=\" + list + \", set=\" + set + \", map=\" + map + \", props=\" + props + '&#125;'; &#125;&#125; f.使用注解注入自定义bean类型数据在bean中的属性上通过@Autowired实现自定义bean类型的属性注入代码1234567891011121314151617181920@Componentpublic class Hero &#123; @Value(\"亚索\") private String name; @Value(\"10\") private int age; @Autowired @Qualifier(\"JMDog\")//一旦配置了@Qualifier(\"JMDog\")会按照指定id注入，找到注入，找不到就抛出异常 //@Resource(name = \"JMDog\") Java提供的不是Spring提供的，基本不用 private Dog dog; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", dog=\" + dog + '&#125;'; &#125;&#125; 当Spring容器解析到@Component注解时，创建当前类的bean在Spring容器中进行管理，在创建bean的过程中发现了@Autowired注解，会根据当前bean的类型，寻找Spring中是否存在该类型的bean，如果唯一的bean，直接注入，如果有多个根据id判断，如果有注入，如果没有抛出异常 其次，可以额外配置@Qualifier（“”）注解强制要求按照id进行寻找，找到就注入，找不到就抛出异常，注意@Autowired&@Qualifier（“”）需要配合使用 其他注解 @Scope(value=”prototype”) 配置修饰类是单例还是多例，Spring默认是单例12345//配置bean为多例@Component@Scope(\"prototype\")public class Person &#123;&#125; @Lazy 配置修饰的类的bean采用懒加载机制 Spring默认在初始化时就通过反射创建对象，并且以键值对的形式存入Spring容器中的Map集合中，在类上配置懒加载的注释，可以在对象使用时再创建，避免内存的浪费1234567@Component@Lazy//懒加载public class Person2 &#123; public Person2() &#123; System.out.println(\"person2...init\"); &#125;&#125; @PostConstruct 在bean对应的类中 修饰某个方法 将该方法声明为初始化方法，对象创建之后立即执 行。1234@PostConstruct public void initConn()&#123; System.out.println(\"初始化数据库连接\"); &#125; @PreDestroy 在bean对应的类中 修饰某个方法 将该方法声明为销毁的方法，对象销毁之前调用的方 法。1234@PreDestroy public void destroyConn()&#123; System.out.println(\"销毁数据库连接\"); &#125; @Controller @Service @Repository @Component 这四个注解的功能是完全相同的，都是用来修饰类，将雷声名为Spring管理的bean的 @Component 一般认为是通用的注解 @Controller 用在软件分层的控制层，一般用在web层上 @Service用在业务访问层，service层 @Repository用在数据访问层（Dao层） 利用Spring IOC DI 实现软件分层解耦 软件分层思想回顾 在软件领域有MVC软件设计思想，指导着软件开发过程。在javaee开发领域，javaee 的经典三层架构MVC设计思想的经典应用。而在软件设计思想中，追求的是”高内聚 低 耦合”的目标，利用Spring的IOC 和 DI 可以非常方便的实现这个需求。 12345678910111213141516171819202122232425262728293031323334353637383940//创建不同类的数据的类型实现userDao接口@Repository(\"userDao\")public class OracleUserDao implements UserDao&#123; @Override public void addUser() &#123; System.out.println(this+\"正在向数据库添加用户\"); &#125;&#125;@Repositorypublic class MySqlUserDao implements UserDao &#123; @Override public void addUser() &#123; System.out.println(this+\"正在添加用户\"); &#125;&#125;public interface UserDao &#123; public void addUser();&#125;//service层@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserDao userDao = null; @Override public void regist() &#123; userDao.addUser(); &#125;&#125;public interface UserService &#123; public void regist();&#125;//web层@Controllerpublic class RegistServlet &#123; @Autowired private UserService service = null; public void regist() &#123; service.regist(); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-01-28T08:37:29.000Z","updated":"2020-02-01T11:53:20.471Z","comments":true,"path":"2020/01/28/单例模式/","link":"","permalink":"http://yoursite.com/2020/01/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式（饿汉式静态变量）1234567891011121314151617181920212223242526public class SingleTest1 &#123; @Test public void test()&#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance==instance1);//true &#125;&#125;//饿汉式（静态变量）//优点：这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题//缺点：没有实现lazy loading的效果，实例创建可能不会被使用，导致内存的浪费class Singleton&#123; //私有化构造方法，目的：不让外界随便创建实例 private Singleton()&#123; &#125; //本类部自己创建实例 private static Singleton instance = new Singleton(); //对外界提供公共的静态方法，返回实例的对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 饿汉式（静态代码块）1234567891011121314151617181920212223242526272829303132333435public class SingleTest2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton2 instance = Singleton2.getInstance(); Singleton2 instance1 = Singleton2.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//饿汉式（静态代码块）//优点：这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题//缺点：没有实现lazy loading的效果，实例创建可能不会被使用，导致内存的浪费class Singleton2 &#123; //私有化构造方法，目的：不让外界随便创建实例 private Singleton2() &#123; &#125; //在本类中声明实例 private static Singleton2 instance; static &#123; //在静态代码块中实例化对象 instance = new Singleton2(); &#125; //对外界提供公共的静态方法，返回实例的对象 public static Singleton2 getInstance() &#123; return instance; &#125;&#125; 单例设计模式（懒汉式线程不安全）123456789101112131415161718192021222324252627public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//懒汉式（多线程不安全）class Singleton &#123; private static Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 123456789101112131415161718192021222324252627282930public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//懒汉式（线程安全）//优点：解决了线程安全的问题//缺点：效率太低,不推荐使用class Singleton &#123; private static Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象,提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检查解决了多线程安全问题12345678910111213141516171819202122232425262728293031323334353637public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;// 双重检查 class Singleton &#123;//volatile防止指令重排推荐使用 private static volatile Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象 public static synchronized Singleton getInstance() &#123; //第一次检查 if (instance == null) &#123; synchronized (Singleton.class) &#123; //第二次检查 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类利用jvm的装载机制，当类加载时静态内部类不会立即被加载，保证了线程安全以及效率的问题1234567891011121314151617181920212223242526272829303132public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//静态内部类class Singleton &#123; private static volatile Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; private static class SingleInstance &#123; private static final Singleton instance = new Singleton(); &#125; //需要时再创建对象,提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() &#123; return SingleInstance.instance; &#125;&#125; 枚举使用枚举，可以实现单例，推荐使用，还能防止反序列化创建对象123456789101112131415161718public class SingletonTest8 &#123; public static void main(String[] args) &#123; Singleton instance = Singleton.INSTANCE; Singleton instance1 = Singleton.INSTANCE; System.out.println(instance == instance1);//true System.out.println(instance.hashCode()); System.out.println(instance1.hashCode()); &#125;&#125;enum Singleton &#123; INSTANCE;//属性 public void sayOk() &#123; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"My-first-blog","slug":"My-first-blog","date":"2020-01-28T04:21:00.000Z","updated":"2020-01-28T04:37:19.618Z","comments":true,"path":"2020/01/28/My-first-blog/","link":"","permalink":"http://yoursite.com/2020/01/28/My-first-blog/","excerpt":"","text":"Mac下 hexo博客的搭建安装Node.js这里可以去Nodejs的官网去下载安装 [hyperlink]（https://nodejs.org/en/） 点击downloads 选择合适的版本下载 打开电脑的终端切换到我们的sudo用户，这里是以管理员身份打开 执行代码：sudo su 显示Password：“输入密码” 查看node的版本，npm的版本 执行代码: node -v 执行代码: npm -v 安装hexo的框架这里使用npm包安装管理器来安装一个淘宝的cnpm的镜像源包安装管理器来安装 执行代码：npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后可以用代码cnpm 查看版本 用cnpm全局安装hexo博客 执行代码：cnpm install -g hexo-cli 安装完成后用hexo -v查看版本，确认安装完成。 查看当前路径:pwd 新建一个blog的文件夹 ：mkdir blog 注意！！！下面的所有操作都是在blog文件下操作，如果后面发生错误实在找不到删除blog文件夹重新操作即可。 进入blog文件夹，执行命令：cd blog hexo初始化 执行命令sudo hexo init 最后启动hexo blog 执行命令：hexo s 默认在http://localhost:4000/可以打开","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-27T03:52:03.728Z","updated":"2020-01-28T08:35:01.012Z","comments":true,"path":"2020/01/27/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]}]}