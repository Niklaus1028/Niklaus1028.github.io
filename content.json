{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Niklaus Yu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-01-28T03:07:35.000Z","updated":"2020-01-28T03:10:00.598Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-01-28T03:13:25.000Z","updated":"2020-01-28T03:17:26.016Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Design Patterns","slug":"Design-Patterns","date":"2020-01-31T04:53:50.000Z","updated":"2020-02-01T10:13:04.969Z","comments":true,"path":"2020/01/31/Design-Patterns/","link":"","permalink":"http://yoursite.com/2020/01/31/Design-Patterns/","excerpt":"","text":"设计模式的类型设计模式分为三种类型，共23种 创建型模式：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。 结构型模式：适配器模式，装饰者模式，桥接模式，组合模式，外观模式，享元模式，代理模式 行为型模式：模版方法模式，命令模式，访问者模式，迭代器模式，观察者模式，备忘录模式，解释器模式（interpreter模式），状态模式，策略模式，职责链模式（责任链）模式。设计模式常用的七大原则1.单一职责原则 降低类的复杂度，一个类只负责一项职责 便于后期的代码的维护，提高代码的刻度性 降低后期因变更而引起的风险 通常情况下我们应该遵循单一职责原则，但在一个类中方法较少的时候，我们可以在方法的级别保持单一职责原则即可 2. 接口隔离原则 一个类通过接口依赖另一个类，该接口应该是最小接口，也就是通过接口的隔离保证类中不需要接口中多余的方法，如果接口中有用不到的方法，就把这个接口中拆分成多个小接口，避免造成浪费。 3. 依赖倒转原则（Dependence Inversion Principle）案例12345678910111213141516171819202122232425262728293031323334public class DependcyIversion &#123; public static void main(String[] args) &#123; Person person = new Person(); person.receive(new Email()); person.receive(new Weixin()); &#125;&#125;interface Ireceiver &#123; String getInfo();&#125;class Email implements Ireceiver &#123; @Override public String getInfo() &#123; return \"hello world\"; &#125;&#125;class Weixin implements Ireceiver &#123; @Override public String getInfo() &#123; return \"one world,one dream\"; &#125;&#125;class Person &#123; public void receive(Ireceiver ireceiver) &#123; System.out.println(ireceiver.getInfo()); &#125;&#125;//总结：通过类与接口发生依赖，与子实现类没有关系，这样便于后期的修改，这就是面向接口编程的思想 低层模块最好是抽象类或者接口，这样程序会更稳定 变量声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利用程序扩展和优化 继承时遵循里氏替换原则 4. 里氏替换原则 继承增加了程序的耦合性 子类尽量不要重写父类的方法，如果需要重写，就通过依赖，组合，聚合的方法，提升一个基类，让原有的父类和子类继承这个基类案例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(\"11-3=\" + a.fun1(11, 3)); System.out.println(\"1-8=\" + a.fun1(1, 8)); System.out.println(\"-----------\"); B b = new B(); System.out.println(\"11+3=\" + b.fun1(11, 3)); System.out.println(\"1+8=\" + b.fun1(1, 8)); System.out.println(\"11+3+9=\" + b.fun2(11, 3)); System.out.println(\"11-3=\" + b.fun3(11, 3)); &#125;&#125;class Base &#123;&#125;class A extends Base &#123; public int fun1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;//B类继承了A//增加了一个新功能：完成两个数相加，然后和9求和class B extends Base &#123; //通过依赖的方式与类A发生关系 private A a = new A(); public int fun1(int a, int b) &#123; return a + b; &#125; public int fun2(int a, int b) &#123; return fun1(a, b) + 9; &#125; public int fun3(int a, int b) &#123; return this.a.fun1(a, b); &#125;&#125; 5. 开闭原则 ocp(open closed principle) 是编程中最基础，最重要的设计原则6. 迪米特法则（最少知道原则） 降低类之间的耦合，对自己依赖的类知道的越少越好 降低类间（对象间）耦合关系，并不是要求完全没有依赖关系 直接朋友，出现在成员变量，方法参数，方法返回值，如果出现在局部变量中则是陌生朋友7. 合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo1 &#123; @Test public void test()&#123; Dog d = new Dog(); d.setAnimal(); &#125;&#125;class Animal &#123; void run()&#123; System.out.println(\"正在跑\"); &#125; void sleep()&#123; System.out.println(\"正在睡\"); &#125; void eat()&#123; System.out.println(\"正在吃\"); &#125;&#125;//方式一依赖/*class Dog &#123; public void action(Animal animal)&#123; animal.run(); animal.eat(); &#125;&#125;*///方式二聚合/*class Dog &#123; private Animal animal; public void setAnimal(Animal animal)&#123; animal.eat(); &#125;&#125;*///方式三：组合class Dog &#123; private Animal animal = new Animal(); public void setAnimal() &#123; animal.eat(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"框架","slug":"框架","date":"2020-01-29T04:22:20.000Z","updated":"2020-01-29T15:01:53.732Z","comments":true,"path":"2020/01/29/框架/","link":"","permalink":"http://yoursite.com/2020/01/29/%E6%A1%86%E6%9E%B6/","excerpt":"","text":"框架（半成品软件）高度抽取可重用代码的一种设计，高度的通用性; 框架：抽取成一种高度可重用的；事务控制，强大的servlet，项目中的一些工具。 框架：多个可重用模块的集合，形成一个某个领域的整体解决方案； Spring 框架容器（可以管理所有的组件（类））框架；核心关注：IOC和AOP模块Test ：Spring的单元测试模块；Core Container：核心容器（IOC）；黑色代表这部分的功能由那些jar包组成；要使用这个部分的完整功能，这些jar包都需要导入（AOP+Aspects）（面向切面编程模块）数据访问 Spring访问数据库模块Web：Spring开发web应用模块","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-01-28T08:37:29.000Z","updated":"2020-02-01T11:53:20.471Z","comments":true,"path":"2020/01/28/单例模式/","link":"","permalink":"http://yoursite.com/2020/01/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式（饿汉式静态变量）1234567891011121314151617181920212223242526public class SingleTest1 &#123; @Test public void test()&#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance==instance1);//true &#125;&#125;//饿汉式（静态变量）//优点：这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题//缺点：没有实现lazy loading的效果，实例创建可能不会被使用，导致内存的浪费class Singleton&#123; //私有化构造方法，目的：不让外界随便创建实例 private Singleton()&#123; &#125; //本类部自己创建实例 private static Singleton instance = new Singleton(); //对外界提供公共的静态方法，返回实例的对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 饿汉式（静态代码块）1234567891011121314151617181920212223242526272829303132333435public class SingleTest2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton2 instance = Singleton2.getInstance(); Singleton2 instance1 = Singleton2.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//饿汉式（静态代码块）//优点：这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题//缺点：没有实现lazy loading的效果，实例创建可能不会被使用，导致内存的浪费class Singleton2 &#123; //私有化构造方法，目的：不让外界随便创建实例 private Singleton2() &#123; &#125; //在本类中声明实例 private static Singleton2 instance; static &#123; //在静态代码块中实例化对象 instance = new Singleton2(); &#125; //对外界提供公共的静态方法，返回实例的对象 public static Singleton2 getInstance() &#123; return instance; &#125;&#125; 单例设计模式（懒汉式线程不安全）123456789101112131415161718192021222324252627public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//懒汉式（多线程不安全）class Singleton &#123; private static Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 123456789101112131415161718192021222324252627282930public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//懒汉式（线程安全）//优点：解决了线程安全的问题//缺点：效率太低,不推荐使用class Singleton &#123; private static Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象,提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检查解决了多线程安全问题12345678910111213141516171819202122232425262728293031323334353637public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;// 双重检查 class Singleton &#123;//volatile防止指令重排推荐使用 private static volatile Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; //需要时再创建对象 public static synchronized Singleton getInstance() &#123; //第一次检查 if (instance == null) &#123; synchronized (Singleton.class) &#123; //第二次检查 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类利用jvm的装载机制，当类加载时静态内部类不会立即被加载，保证了线程安全以及效率的问题1234567891011121314151617181920212223242526272829303132public class SingleDemo2 &#123; @Test public void test() &#123; //通过调用静态方法来创建实例 Singleton instance = Singleton.getInstance(); Singleton instance1 = Singleton.getInstance(); //证明不管多少次调用Singleton类同一个实例 System.out.println(instance == instance1);//true &#125;&#125;//静态内部类class Singleton &#123; private static volatile Singleton instance; //私有化构造方法 private Singleton() &#123; &#125; private static class SingleInstance &#123; private static final Singleton instance = new Singleton(); &#125; //需要时再创建对象,提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() &#123; return SingleInstance.instance; &#125;&#125; 枚举使用枚举，可以实现单例，推荐使用，还能防止反序列化创建对象123456789101112131415161718public class SingletonTest8 &#123; public static void main(String[] args) &#123; Singleton instance = Singleton.INSTANCE; Singleton instance1 = Singleton.INSTANCE; System.out.println(instance == instance1);//true System.out.println(instance.hashCode()); System.out.println(instance1.hashCode()); &#125;&#125;enum Singleton &#123; INSTANCE;//属性 public void sayOk() &#123; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"My-first-blog","slug":"My-first-blog","date":"2020-01-28T04:21:00.000Z","updated":"2020-01-28T04:37:19.618Z","comments":true,"path":"2020/01/28/My-first-blog/","link":"","permalink":"http://yoursite.com/2020/01/28/My-first-blog/","excerpt":"","text":"Mac下 hexo博客的搭建安装Node.js这里可以去Nodejs的官网去下载安装 [hyperlink]（https://nodejs.org/en/） 点击downloads 选择合适的版本下载 打开电脑的终端切换到我们的sudo用户，这里是以管理员身份打开 执行代码：sudo su 显示Password：“输入密码” 查看node的版本，npm的版本 执行代码: node -v 执行代码: npm -v 安装hexo的框架这里使用npm包安装管理器来安装一个淘宝的cnpm的镜像源包安装管理器来安装 执行代码：npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后可以用代码cnpm 查看版本 用cnpm全局安装hexo博客 执行代码：cnpm install -g hexo-cli 安装完成后用hexo -v查看版本，确认安装完成。 查看当前路径:pwd 新建一个blog的文件夹 ：mkdir blog 注意！！！下面的所有操作都是在blog文件下操作，如果后面发生错误实在找不到删除blog文件夹重新操作即可。 进入blog文件夹，执行命令：cd blog hexo初始化 执行命令sudo hexo init 最后启动hexo blog 执行命令：hexo s 默认在http://localhost:4000/可以打开","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-27T03:52:03.728Z","updated":"2020-01-28T08:35:01.012Z","comments":true,"path":"2020/01/27/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"导航","slug":"导航","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"}]}]}